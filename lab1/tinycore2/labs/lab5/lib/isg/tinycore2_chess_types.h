
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Tue Jan 15 15:18:08 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -Pc -Iisg +wisg -D__tct_patch__=300 -D__chess__ -D__programmers_view__ tinycore2

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Native C++ types and functions

#ifndef _tinycore2_chess_types_h
#define _tinycore2_chess_types_h

#include "chess.h"
#include "vbit.h"

#include "tinycore2_iss_types.h"


//  Application types (declarations)

//  (none)



//  Built-in type wrappers (bit-true behaviour or used as vector element type)

namespace tinycore2_BT {

//class BTbool /* std C conforming */

// fewer bits
class BT__sint
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    BT__sint() {}
    template <int B, bool S> BT__sint(const VBit<B, S>& a) : val(a) {}
    BT__sint(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> BT__sint(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BT__sint(BitType::ValueType a) : val(a) {}
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const BT__sint& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, BT__sint& x) { is >> x.val; return is; }
public:
    operator BitType::ValueType() const { return val.value(); }
    BT__sint& operator=(BitType::ValueType a) { val = a; return *this; }
    BT__sint& operator+=(const BT__sint& a) { val += a.val; return *this; }
    BT__sint& operator-=(const BT__sint& a) { val -= a.val; return *this; }
    BT__sint& operator*=(const BT__sint& a) { val *= a.val; return *this; }
    BT__sint& operator/=(const BT__sint& a) { val /= a.val; return *this; }
    BT__sint& operator%=(const BT__sint& a) { val %= a.val; return *this; }
    BT__sint& operator&=(const BT__sint& a) { val &= a.val; return *this; }
    BT__sint& operator|=(const BT__sint& a) { val |= a.val; return *this; }
    BT__sint& operator^=(const BT__sint& a) { val ^= a.val; return *this; }
    BT__sint& operator<<=(const int& a) { val <<= a; return *this; }
    BT__sint& operator>>=(const int& a) { val >>= a; return *this; }
    BT__sint& operator++() { ++val; return *this; }
    BT__sint operator++(int) { BT__sint i = *this; val++; return i; }
    BT__sint& operator--() { --val; return *this; }
    BT__sint operator--(int) { BT__sint i = *this; val--; return i; }
};
inline const BT__sint::BitType& toBitType(const BT__sint& v) { return v.val; }
// fewer bits
class BT__uint
{
public:
    typedef VBit<16, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    BT__uint() {}
    template <int B, bool S> BT__uint(const VBit<B, S>& a) : val(a) {}
    BT__uint(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> BT__uint(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BT__uint(BitType::ValueType a) : val(a) {}
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const BT__uint& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, BT__uint& x) { is >> x.val; return is; }
public:
    operator BitType::ValueType() const { return val.value(); }
    BT__uint& operator=(BitType::ValueType a) { val = a; return *this; }
    BT__uint& operator+=(const BT__uint& a) { val += a.val; return *this; }
    BT__uint& operator-=(const BT__uint& a) { val -= a.val; return *this; }
    BT__uint& operator*=(const BT__uint& a) { val *= a.val; return *this; }
    BT__uint& operator/=(const BT__uint& a) { val /= a.val; return *this; }
    BT__uint& operator%=(const BT__uint& a) { val %= a.val; return *this; }
    BT__uint& operator&=(const BT__uint& a) { val &= a.val; return *this; }
    BT__uint& operator|=(const BT__uint& a) { val |= a.val; return *this; }
    BT__uint& operator^=(const BT__uint& a) { val ^= a.val; return *this; }
    BT__uint& operator<<=(const int& a) { val <<= a; return *this; }
    BT__uint& operator>>=(const int& a) { val >>= a; return *this; }
    BT__uint& operator++() { ++val; return *this; }
    BT__uint operator++(int) { BT__uint i = *this; val++; return i; }
    BT__uint& operator--() { --val; return *this; }
    BT__uint operator--(int) { BT__uint i = *this; val--; return i; }
};
inline const BT__uint::BitType& toBitType(const BT__uint& v) { return v.val; }
} //namespace tinycore2_BT


//  Application types (definitions)

//  Application types (additional)

#ifndef do_not_generate_additional_appl_types /*trouble-shooting hook*/

#endif /*do_not_generate_additional_appl_types*/


//  Conversions


//  Operations

//TBD

//  Chess_message hook for printing text between chess_reports (native only)

#define chess_message(msg) std::cout << msg << std::endl


#ifndef do_not_generate_chess_assert /*trouble-shooting hook*/

//  Chess_assert ancillary functions (native emulating ISS)

#define chess_assert(val)  (void)(chess_assert_(val)||chess_assert_msg(__FILE__,__LINE__))

inline int chess_assert_msg(const char* file, int line) {
    std::cout.flush();
    std::cerr << "ERROR Assertion failed in \"" << file << "\", line " << line << '.' << std::endl;
    return 0;
}

//  Overloaded chess_assert functions (allow to assert types without operator bool())

inline int chess_assert_(bool a) {
  return a != 0 ? 1 : 0;
}
inline int chess_assert_(int a) {
  return a != 0 ? 1 : 0;
}
inline int chess_assert_(unsigned a) {
  return a != 0 ? 1 : 0;
}
inline int chess_assert_(void* a) {
  return a != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_primitive::word a) {
  return toVBit(a) != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_primitive::pmtype a) {
  return toVBit(a) != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_primitive::sbyte a) {
  return toVBit(a) != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_primitive::ubyte a) {
  return toVBit(a) != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_primitive::threebitsu a) {
  return toVBit(a) != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_BT::BT__sint a) {
  return toVBit(a) != 0 ? 1 : 0;
}
inline int chess_assert_(tinycore2_BT::BT__uint a) {
  return toVBit(a) != 0 ? 1 : 0;
}

#endif /*!do_not_generate_chess_assert*/


#ifndef do_not_generate_chess_report /*trouble-shooting hook*/

//  Chess_report ancillary functions (common to ISS and native)

inline void chess_report_hex(int bits, long long val, std::ostream& os)
    { os << " 0x" << std::hex << std::setfill('0') << std::setw((bits+3)/4) << CHESS_MASKLL(val,bits); }
inline void chess_report_signed  (long long  val, std::ostream& os)
    { os << ' ' << std::dec << val; }
inline void chess_report_unsigned(unsigned long long val, std::ostream& os)
    { os << ' ' << std::dec << val; }

//  Overloaded chess_report functions

inline void chess_report(bool a) {
    std::ostream& os = std::cout;
    os << "chess_report(bool):";
    chess_report_hex(1, a, os);
    os << " //";
    chess_report_unsigned(a, os);
    os << std::endl;
}
inline void chess_report(int a) {
    std::ostream& os = std::cout;
    os << "chess_report(int):";
    chess_report_hex(16, a, os);
    os << " //";
    chess_report_signed(a, os);
    os << std::endl;
}
inline void chess_report(unsigned a) {
    std::ostream& os = std::cout;
    os << "chess_report(unsigned):";
    chess_report_hex(16, a, os);
    os << " //";
    chess_report_unsigned(a, os);
    os << std::endl;
}
inline void chess_report(const volatile void* a) {
    std::ostream& os = std::cout;
    os << "chess_report(void*):";
    chess_report_hex(sizeof(void*)*8/*no mask*/, (unsigned long long)a, os);
    os << " //";
    chess_report_unsigned((unsigned long long)a, os);
    os << std::endl;
}
inline void chess_report(tinycore2_primitive::word a) {
    std::ostream& os = std::cout;
    os << "chess_report(tinycore2_primitive::word):";
    chess_report_hex(16, toVBit(a).value(), os);
    os << " //";
    chess_report_signed(toVBit(a).value(), os);
    os << std::endl;
}
inline void chess_report(tinycore2_primitive::pmtype a) {
    std::ostream& os = std::cout;
    os << "chess_report(tinycore2_primitive::pmtype):";
    chess_report_hex(14, toVBit(a).value(), os);
    os << " //";
    chess_report_unsigned(toVBit(a).value(), os);
    os << std::endl;
}
inline void chess_report(tinycore2_primitive::sbyte a) {
    std::ostream& os = std::cout;
    os << "chess_report(tinycore2_primitive::sbyte):";
    chess_report_hex(8, toVBit(a).value(), os);
    os << " //";
    chess_report_signed(toVBit(a).value(), os);
    os << std::endl;
}
inline void chess_report(tinycore2_primitive::ubyte a) {
    std::ostream& os = std::cout;
    os << "chess_report(tinycore2_primitive::ubyte):";
    chess_report_hex(8, toVBit(a).value(), os);
    os << " //";
    chess_report_unsigned(toVBit(a).value(), os);
    os << std::endl;
}
inline void chess_report(tinycore2_primitive::threebitsu a) {
    std::ostream& os = std::cout;
    os << "chess_report(tinycore2_primitive::threebitsu):";
    chess_report_hex(3, toVBit(a).value(), os);
    os << " //";
    chess_report_unsigned(toVBit(a).value(), os);
    os << std::endl;
}
inline void chess_report(tinycore2_BT::BT__sint a) {
    std::ostream& os = std::cout;
    os << "chess_report(int):";
    chess_report_hex(16, toVBit(a).value(), os);
    os << " //";
    chess_report_signed(toVBit(a).value(), os);
    os << std::endl;
}
inline void chess_report(tinycore2_BT::BT__uint a) {
    std::ostream& os = std::cout;
    os << "chess_report(unsigned):";
    chess_report_hex(16, toVBit(a).value(), os);
    os << " //";
    chess_report_unsigned(toVBit(a).value(), os);
    os << std::endl;
}

#endif /*!do_not_generate_chess_report*/


#ifndef do_not_generate_chess_cycle_count /*trouble-shooting hook*/

// stub, but with correct (largest suitable) return type on tinycore2 (may influence C++ overloading)
inline unsigned chess_cycle_count() { return 0; }

#endif /*!do_not_generate_chess_cycle_count*/


#ifndef do_not_generate_chess_return_address /*trouble-shooting hook*/

#if defined __GNUC__
#define chess_return_address() ((void*)__builtin_return_address(0))
#elif defined _WIN32
#include <intrin.h>
#pragma intrinsic(_ReturnAddress)
#define chess_return_address() ((void*)_ReturnAddress())
#else /*stub*/
#define chess_return_address() ((void*)0)
#endif

#endif /*!do_not_generate_chess_return_address*/


#ifndef do_not_generate_chess_stop_exit /*trouble-shooting hook*/

#include <stdlib.h>
#define chess_stop()  _Exit(0)

#define chess_exit(x) _Exit(x)

#endif /*!do_not_generate_chess_stop_exit*/


#ifndef do_not_generate_chess_dont_care /*trouble-shooting hook*/

#define chess_dont_care(T) chess_dont_care_<T>()
template<typename T>
T chess_dont_care_() { return T(); }
#endif /*!do_not_generate_chess_dont_care*/


#define chess_error(x) chess_stop()



#endif /*_tinycore2_chess_types_h*/
