
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Tue Jan 15 15:18:10 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -pa -Iisg +wisg -D__tct_patch__=300 -D__darts__ -D__programmers_view__ tinycore2

toolrelease _18R1;

//-- CHESS GENERIC TYPES AND PRIMITIVES --

typ any<0>;
typ void<0>;
prim typ bool<1u>[0,1,1];

// general properties:

add_sub_inv {
}
chess_view {
}
chess_view_opn {
}
commutative {
}
conversion {
}
dont_disable_chess_view {
}
envelope {
}
envelope_open : envelope {
}
envelope_close : envelope {
}
isr_envelope_open : envelope_open {
}
isr_envelope_close : envelope_close {
}
event_opn {
}
early_clobbers {
}
expensive {
}
explicit {
}
immediate_repeat_count {
}
inlined {
}
isolate_status_uses {
}
multicycle {
}
no_duplicate_move {
}
no_pdg_definition {
}
primitive {
}
promoted {
}
promotion_conversion {
}
right_padding {
}
right_truncate {
}
unfoldable {
}
unused {
}
user_defined {
}
volatile {
}

assembly : event_opn, volatile {
}
called : event_opn {
}
chess_hosted : called {
}
chess_assert : chess_hosted, volatile {
}
chess_report : chess_hosted, volatile {
}
chess_stop : chess_hosted, volatile {
}
chess_cycle_count : chess_hosted {
}
chess_exit : chess_hosted, volatile {
}
chess_hosted_io : chess_hosted, volatile {
}
chess_separator : called {
}
chess_separator_scheduler : chess_separator {
}
chess_instruction_tracing_begin : chess_separator_scheduler {
}
chess_instruction_tracing_end : chess_separator_scheduler {
}
chess_profile_begin : chess_separator_scheduler {
}
chess_profile_end : chess_separator_scheduler {
}
chess_seqloop_test : chess_separator_scheduler {
}
chess_seqloop_end : chess_separator_scheduler {
}
chess_tcl_break : chess_separator_scheduler {
}
isr : event_opn {
}

nop : volatile {
}
never_returns : volatile {
}

instruction_properties {
}
instruction_class : instruction_properties {
}
cycles : instruction_properties {
}
words : instruction_properties {
}
alt_cycles : instruction_properties {
}
delay_slots : instruction_properties {
}
pc_offset : instruction_properties {
}

// SFG annotations:

chess_frequent_else : event_opn {
}
chess_frequent_then : event_opn {
}
chess_no_warn_pipelining : event_opn {
}

// source/sink operations:

inp : event_opn {
    arg : ( any:o );
}
out : event_opn {
    arg : ( any:i );
}
tr_inp : event_opn {
    arg : ( any:o );
}
tr_out : event_opn {
    arg : ( any:i );
}

st_def : event_opn {
    arg : ( any:o );
}
source : event_opn {
    arg : ( any:o );
}
sink : event_opn {
    arg : ( any:i );
}
sync_sink : sink {
}
to_route_sink : sink {
}
seqif_sink : event_opn {
    arg : ( any:i );
}

const : event_opn {
    arg : ( any:o );
}
const_inp : event_opn {
    arg : ( any:o );
}

undefined : event_opn {
    arg : ( any:o );
}
never : undefined {
}

chain_tie : event_opn {
}

keep_dead : event_opn {
    arg : ( any:i );
}

// flow operations:

flow_opn : event_opn {
}
fork : flow_opn {
    arg : ( any:o any:o any:i );
}
join : flow_opn {
    arg : ( any:o any:i any:i );
}

branch : fork {
}
merge : join {
}
gmerge : join {
}

entry : join {
}
exit : fork {
}

call_link : flow_opn {
    arg : ( any:o any:i );
}
// irremovable call link:
defval_call_link : event_opn {
    arg : ( any:o any:i );
}

sync_link : flow_opn {
    arg : ( any:o any:i );
}
sync_never : flow_opn {
    arg : ( any:o any:i );
}
// var assignment in C:
assign : event_opn {
    arg : ( any:r any:i );
}
deassign : assign {
}
direct_assign : assign {
}
strict_assign : assign {
}
// conversion without move:
in_situ_conv : event_opn {
    arg : ( any:r any:i );
}
// trn assignment in nML:
copy {
    arg : ( any:r any:i );
}
excl_in_move {
}

// heading operations:

heading : event_opn {
    arg : ( any:i );
}
if_expr : heading {
}
else_expr : event_opn {
    arg : ( any:i );
}
while_expr : heading {
}
for_count : heading {
}

// control operations:

cntrl {
}
absolute {
}
relative {
}
seqelsif {
}

call : cntrl {
}
near_call : cntrl {
}
doloop : cntrl {
}
doloop_no_cntrl : cntrl {
}
repeat : cntrl {
}
halt : cntrl, volatile {
}
jump : cntrl {
}
jti : jump {
}
ret : cntrl {
}
near_ret : cntrl {
}
rti : ret {
}
zloop_sink : event_opn {
    arg : ( any:i any:i any:i );
}
zloop_sink_absolute : zloop_sink, absolute {
}
zloop_sink_relative : zloop_sink, relative {
}

multi_register_pop {
}
multi_register_push {
}

// storage operations:

storage_opn {
}
l_storage_opn : storage_opn {
}
s_storage_opn : storage_opn {
}

a_fetch : l_storage_opn {
    arg : ( any:r any:i any:i );
}
a_update : s_storage_opn {
    arg : ( any:o any:i any:i );
}

load : a_fetch {
}
store : a_update {
}

read_file : a_fetch {
}
write_file : a_update {
}

read_reg : l_storage_opn {
    arg : ( any:r any:i );
}
write_reg : s_storage_opn {
    arg : ( any:r any:i );
}

// alternate storage operations:

alt_load {
}
alt_store {
}
guarded_load : alt_load {
}
guarded_store : alt_store {
}
select {
}

// reserved register access:
rd_res_reg {
    arg : ( any:r any:i );
}
wr_res_reg {
    arg : ( any:o any:i );
}

// bundles:

bndl_opn {
}
// functional bundle generated by cosel:
func_bndl : bndl_opn {
}
// move bundle generated by amnesia, showcolor & rover:
mv_bndl : bndl_opn {
    arg : ( any:r any:i );
}

namespace {
}


//-- PRIMITIVE TYPES --

prim typ word<16t>[-32768,32767,1];
prim typ pmtype<14u>[0,16383,1];
prim typ sbyte<8t>[-128,127,1];
prim typ ubyte<8u>[0,255,1];
prim typ threebitsu<3u>[0,7,1];


//-- PRIMITIVE OPERATIONS --

// /*primitive*/ word add(word, word)
word_add_word_word : user_defined, commutative, primitive {
    fnm : "add" '/*primitive*/ word add(word, word)'; 
    arg : ( word:r word:i word:i );
}

// /*primitive*/ word sub(word, word)
word_sub_word_word : user_defined, primitive {
    fnm : "sub" '/*primitive*/ word sub(word, word)'; 
    arg : ( word:r word:i word:i );
}

// /*primitive*/ word band(word, word)
word_band_word_word : user_defined, commutative, primitive {
    fnm : "band" '/*primitive*/ word band(word, word)'; 
    arg : ( word:r word:i word:i );
}

// /*primitive*/ word bor(word, word)
word_bor_word_word : user_defined, commutative, primitive {
    fnm : "bor" '/*primitive*/ word bor(word, word)'; 
    arg : ( word:r word:i word:i );
}

// /*primitive*/ bool lt(word, word)
bool_lt_word_word : user_defined, primitive {
    fnm : "lt" '/*primitive*/ bool lt(word, word)'; 
    arg : ( bool:r word:i word:i );
}

// /*primitive*/ bool le(word, word)
bool_le_word_word : user_defined, primitive {
    fnm : "le" '/*primitive*/ bool le(word, word)'; 
    arg : ( bool:r word:i word:i );
}

// /*primitive*/ bool gt(word, word)
bool_gt_word_word : user_defined, primitive {
    fnm : "gt" '/*primitive*/ bool gt(word, word)'; 
    arg : ( bool:r word:i word:i );
}

// /*primitive*/ bool ge(word, word)
bool_ge_word_word : user_defined, primitive {
    fnm : "ge" '/*primitive*/ bool ge(word, word)'; 
    arg : ( bool:r word:i word:i );
}

// /*primitive*/ word ldh(sbyte)
word_ldh_sbyte : user_defined, primitive {
    fnm : "ldh" '/*primitive*/ word ldh(sbyte)'; 
    arg : ( word:r sbyte:i );
}

// /*primitive*/ void jumpi(sbyte)
void_jumpi_sbyte : user_defined, jump, relative, primitive {
    fnm : "jumpi" '/*primitive*/ void jumpi(sbyte)'; 
    arg : ( sbyte:i );
}

// /*primitive*/ void jumpci(bool, sbyte)
void_jumpci_bool_sbyte : user_defined, jump, relative, primitive {
    fnm : "jumpci" '/*primitive*/ void jumpci(bool, sbyte)'; 
    arg : ( bool:i sbyte:i );
}

// /*primitive*/ word bsr(word)
word_bsr_word : user_defined, absolute, call, primitive {
    fnm : "bsr" '/*primitive*/ word bsr(word)'; 
    arg : ( word:r word:i );
}

// /*primitive*/ void rts(word)
void_rts_word : user_defined, ret, primitive {
    fnm : "rts" '/*primitive*/ void rts(word)'; 
    arg : ( word:i );
}

// /*primitive*/ void nop()
void_nop : user_defined, nop, primitive {
    fnm : "nop" '/*primitive*/ void nop()'; 
}

// /*primitive*/ word::word(sbyte)
word_word_sbyte : user_defined, conversion, primitive {
    fnm : "word" '/*primitive*/ word::word(sbyte)'; 
    arg : ( word:r sbyte:i );
}

// /*primitive*/ word::word(ubyte)
word_word_ubyte : user_defined, conversion, primitive {
    fnm : "word" '/*primitive*/ word::word(ubyte)'; 
    arg : ( word:r ubyte:i );
}

