
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Fri Jan 25 16:14:39 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -ps -Iisg +wisg -D__tct_patch__=300 -D__checkers__ tinycore2

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Primitive types and functions
// used in Checkers ISS and PDG (and possibly native)

#ifndef _tinycore2_iss_types_h
#define _tinycore2_iss_types_h

#include "chess.h"
#include "vbit.h"

namespace tinycore2_primitive {

//  Primitive types (declarations)

class word;             // property( 16 bit   signed );
class pmtype;           // property( 14 bit unsigned );
class sbyte;            // property(  8 bit   signed );
class ubyte;            // property(  8 bit unsigned );
class threebitsu;       // property(  3 bit unsigned );


//  Primitive types (definitions)

class word
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    word() {}
    template <int B, bool S> word(const VBit<B, S>& a) : val(a) {}
    word(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> word(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    word(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const word& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, word& x) { is >> x.val; return is; }
public:
    word(sbyte);
    word(ubyte);
};
inline const word::BitType& toBitType(const word& v) { return v.val; }

class pmtype
{
public:
    typedef VBit<14, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    pmtype() {}
    template <int B, bool S> pmtype(const VBit<B, S>& a) : val(a) {}
    pmtype(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> pmtype(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    pmtype(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const pmtype& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, pmtype& x) { is >> x.val; return is; }
public:
};
inline const pmtype::BitType& toBitType(const pmtype& v) { return v.val; }

class sbyte
{
public:
    typedef VBit<8, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    sbyte() {}
    template <int B, bool S> sbyte(const VBit<B, S>& a) : val(a) {}
    sbyte(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> sbyte(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    sbyte(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const sbyte& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, sbyte& x) { is >> x.val; return is; }
public:
};
inline const sbyte::BitType& toBitType(const sbyte& v) { return v.val; }

class ubyte
{
public:
    typedef VBit<8, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    ubyte() {}
    template <int B, bool S> ubyte(const VBit<B, S>& a) : val(a) {}
    ubyte(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> ubyte(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    ubyte(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const ubyte& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, ubyte& x) { is >> x.val; return is; }
public:
};
inline const ubyte::BitType& toBitType(const ubyte& v) { return v.val; }

class threebitsu
{
public:
    typedef VBit<3, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    threebitsu() {}
    template <int B, bool S> threebitsu(const VBit<B, S>& a) : val(a) {}
    threebitsu(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> threebitsu(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    threebitsu(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const threebitsu& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, threebitsu& x) { is >> x.val; return is; }
public:
};
inline const threebitsu::BitType& toBitType(const threebitsu& v) { return v.val; }


//  Conversions

inline word::word(sbyte a)               { val = toVBit(a); }
inline word::word(ubyte a)               { val = toVBit(a); }


//  Operations

checkers_import_export /*primitive*/ word add(word, word);
checkers_import_export /*primitive*/ word sub(word, word);
checkers_import_export /*primitive*/ word band(word, word);
checkers_import_export /*primitive*/ word bor(word, word);
checkers_import_export /*primitive*/ word mul(word, word);
checkers_import_export /*primitive*/ word srl(word, word);

checkers_import_export /*primitive*/ bool lt(word, word);
checkers_import_export /*primitive*/ bool le(word, word);
checkers_import_export /*primitive*/ bool gt(word, word);
checkers_import_export /*primitive*/ bool ge(word, word);

checkers_import_export /*primitive*/ word ldh(sbyte);

//cntrl:  checkers_import_export /*primitive*/ void jumpi(sbyte);
//cntrl:  checkers_import_export /*primitive*/ void jumpci(bool, sbyte);
//cntrl:  checkers_import_export /*primitive*/ word bsr(word);
//cntrl:  checkers_import_export /*primitive*/ void rts(word);

checkers_import_export /*primitive*/ void nop();


} //namespace tinycore2_primitive

#endif /*_tinycore2_iss_types_h*/
