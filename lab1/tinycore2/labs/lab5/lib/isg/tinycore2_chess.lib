
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Fri Jan 25 16:14:37 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -Pc -Iisg +wisg -D__tct_patch__=300 -D__chess__ -D__programmers_view__ tinycore2

toolrelease _18R1;

//-- SPILLING --

pattern {
}

constant_load_parent : pattern {
}
stack_load_parent : pattern {
}
stack_store_parent : pattern {
}

constant_load : constant_load_parent {
}
stack_load : stack_load_parent {
}
stack_store : stack_store_parent {
}

constant_load_indirect : constant_load_parent {
}
stack_load_indirect : stack_load_parent {
}
stack_store_indirect : stack_store_parent {
}

init_rp : pattern {
}
update_cp : pattern {
}
update_rp : pattern {
}
pop_regs : pattern {
}
push_regs : pattern {
}

complex_pattern : pattern {
}

complex_ctpat : complex_pattern {
}
complex_load : complex_pattern {
}
complex_store : complex_pattern {
}
complex_move : complex_pattern {
}

complex_tie : event_opn {
}

complex_ctpat_tie : complex_tie {
}
complex_load_tie : complex_tie {
}
complex_store_tie : complex_tie {
}

// auxiliary patterns defined in the source function sfg file:

aux_pattern {
}

complex_const : aux_pattern {
}


//-- APPLICATION LAYER TYPES --

typ __sint<16t>[-32768,32767,1];
typ __uint<16u>[0,65535,1];
typ __Pvoid<16u>[0,65535,1];

// type promotions

// spill & constant memory differentiation

// chess_properties
prop release_q = ( q18R1 );
prop breakpoint_focus_stage = ( 2 );
prop ctor_list_memory = ( DM );
prop default_memory = ( DM );
prop link_register = ( LR );
prop nr_stacks = ( 0 );
prop representation = ( __sint word __uint word __Pvoid word );
prop reserved = ( PC );
prop status_register = ( SREG );
prop void___complex_ctpat_tie_word_sbyte_ubyte = ( 8 8 0 8 );


//-- APPLICATION LAYER OPERATIONS --

// int operator+(int, int)
__sint__pl___sint___sint : user_defined, commutative, inlined, promoted {
    fnm : "operator+" 'int operator+(int, int)'; 
    arg : ( __sint:r __sint:i __sint:i );
    prm : ( word_add_word_word );
}

// int operator-(int, int)
__sint__mi___sint___sint : user_defined, inlined, promoted {
    fnm : "operator-" 'int operator-(int, int)'; 
    arg : ( __sint:r __sint:i __sint:i );
    prm : ( word_sub_word_word );
}

// int operator*(int, int)
__sint__ml___sint___sint : user_defined, commutative, inlined, promoted {
    fnm : "operator*" 'int operator*(int, int)'; 
    arg : ( __sint:r __sint:i __sint:i );
    prm : ( word_mul_word_word );
}

// int operator>>(int, int)
__sint__rs___sint___sint : user_defined, inlined, promoted {
    fnm : "operator>>" 'int operator>>(int, int)'; 
    arg : ( __sint:r __sint:i __sint:i );
    prm : ( word_srl_word_word );
}

// void chess_stop()
chess_stop : chess_hosted, volatile {
}

// void chess_separator()
chess_separator : called {
}

// void chess_separator_scheduler()
chess_separator_scheduler : chess_separator {
}

// void chess_separator_scheduler(int)
chess_separator_scheduler : chess_separator {
}

// void chess_instruction_tracing_begin()
chess_instruction_tracing_begin : chess_separator_scheduler {
}

// void chess_instruction_tracing_end()
chess_instruction_tracing_end : chess_separator_scheduler {
}

// void chess_profile_begin()
chess_profile_begin : chess_separator_scheduler {
}

// void chess_profile_end()
chess_profile_end : chess_separator_scheduler {
}

// void __complex_ctpat(word &)
void___complex_ctpat_word : complex_ctpat {
    fnm : "__complex_ctpat" 'void __complex_ctpat(word &)'; 
    arg : ( word:o );
}

// void __complex_ctpat_tie(word, sbyte &, ubyte &)
void___complex_ctpat_tie_word_sbyte_ubyte : complex_ctpat_tie {
    fnm : "__complex_ctpat_tie" 'void __complex_ctpat_tie(word, sbyte &, ubyte &)'; 
    arg : ( word:i sbyte:o ubyte:o );
}

// void __pat1_complex_ctpat(word &)
void___pat1_complex_ctpat_word : void___complex_ctpat_word {
    loc : ( R[] );
}

// void chess_assert(bool)
void_chess_assert_bool : chess_assert {
    fnm : "chess_assert" 'void chess_assert(bool)'; 
    arg : ( word:i );
}

// void chess_report(bool)
void_chess_report_bool : chess_report {
    fnm : "chess_report" 'void chess_report(bool)'; 
    arg : ( word:i );
}

// void chess_assert(int)
void_chess_assert___sint : chess_assert {
    fnm : "chess_assert" 'void chess_assert(int)'; 
    arg : ( word:i );
}

// void chess_report(int)
void_chess_report___sint : chess_report {
    fnm : "chess_report" 'void chess_report(int)'; 
    arg : ( word:i );
}

// void chess_assert(unsigned)
void_chess_assert___uint : chess_assert {
    fnm : "chess_assert" 'void chess_assert(unsigned)'; 
    arg : ( word:i );
}

// void chess_report(unsigned)
void_chess_report___uint : chess_report {
    fnm : "chess_report" 'void chess_report(unsigned)'; 
    arg : ( word:i );
}

// void chess_assert(void *)
void_chess_assert___Pvoid : chess_assert {
    fnm : "chess_assert" 'void chess_assert(void *)'; 
    arg : ( word:i );
}

// void chess_report(void *)
void_chess_report___Pvoid : chess_report {
    fnm : "chess_report" 'void chess_report(void *)'; 
    arg : ( word:i );
}

// void chess_assert(void chess_storage(PM) *)
void_chess_assert___PPMvoid : chess_assert {
    fnm : "chess_assert" 'void chess_assert(void chess_storage(PM) *)'; 
    arg : ( word:i );
}

// void chess_report(void chess_storage(PM) *)
void_chess_report___PPMvoid : chess_report {
    fnm : "chess_report" 'void chess_report(void chess_storage(PM) *)'; 
    arg : ( word:i );
}

// void chess_assert(void chess_storage(DM) *)
void_chess_assert___PDMvoid : chess_assert {
    fnm : "chess_assert" 'void chess_assert(void chess_storage(DM) *)'; 
    arg : ( word:i );
}

// void chess_report(void chess_storage(DM) *)
void_chess_report___PDMvoid : chess_report {
    fnm : "chess_report" 'void chess_report(void chess_storage(DM) *)'; 
    arg : ( word:i );
}

// void chess_assert(word)
void_chess_assert_word : chess_assert {
    fnm : "chess_assert" 'void chess_assert(word)'; 
    arg : ( word:i );
}

// void chess_report(word)
void_chess_report_word : chess_report {
    fnm : "chess_report" 'void chess_report(word)'; 
    arg : ( word:i );
}

// void chess_assert(pmtype)
void_chess_assert_pmtype : chess_assert {
    fnm : "chess_assert" 'void chess_assert(pmtype)'; 
    arg : ( pmtype:i );
}

// void chess_report(pmtype)
void_chess_report_pmtype : chess_report {
    fnm : "chess_report" 'void chess_report(pmtype)'; 
    arg : ( pmtype:i );
}

// void chess_assert(sbyte)
void_chess_assert_sbyte : chess_assert {
    fnm : "chess_assert" 'void chess_assert(sbyte)'; 
    arg : ( sbyte:i );
}

// void chess_report(sbyte)
void_chess_report_sbyte : chess_report {
    fnm : "chess_report" 'void chess_report(sbyte)'; 
    arg : ( sbyte:i );
}

// void chess_assert(ubyte)
void_chess_assert_ubyte : chess_assert {
    fnm : "chess_assert" 'void chess_assert(ubyte)'; 
    arg : ( ubyte:i );
}

// void chess_report(ubyte)
void_chess_report_ubyte : chess_report {
    fnm : "chess_report" 'void chess_report(ubyte)'; 
    arg : ( ubyte:i );
}

// void chess_assert(threebitsu)
void_chess_assert_threebitsu : chess_assert {
    fnm : "chess_assert" 'void chess_assert(threebitsu)'; 
    arg : ( threebitsu:i );
}

// void chess_report(threebitsu)
void_chess_report_threebitsu : chess_report {
    fnm : "chess_report" 'void chess_report(threebitsu)'; 
    arg : ( threebitsu:i );
}

// unsigned chess_cycle_count()
__uint_chess_cycle_count : chess_cycle_count {
    fnm : "chess_cycle_count" 'unsigned chess_cycle_count()'; 
    arg : ( word:r );
    loc : ( R[0] );
}

// void chess_exit(int)
void_chess_exit___sint : chess_exit {
    fnm : "chess_exit" 'void chess_exit(int)'; 
    arg : ( word:i );
}

// void chess_hosted_io(void *)
void_chess_hosted_io___Pvoid : chess_hosted_io {
    fnm : "chess_hosted_io" 'void chess_hosted_io(void *)'; 
    arg : ( word:i );
}

