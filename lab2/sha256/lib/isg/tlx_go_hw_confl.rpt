
// File generated by Go version N-2018.03#7d02e3ca79#180723, Thu Feb 28 14:33:27 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.

HW conflicts on transitories of tlx


<<<< Enable option -s to see instruction patterns (may be slow). >>>>


<<<< Enable debug mode (option -d1) to see HW conflicts between
     operations with different 'strength'. >>>>


<<<< Enable option -n to obtain an nML rule derivation for each source reference (may be slow). >>>>


<<<< Enable option -v to obtain all source references for each conflict (may be slow). >>>>



dmb_wr stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dmb_wr_copy0_sxB_EX  : IN( sxB `EX` ) OUT( dmb_wr `EX` )
  <---> 
  dmb_wr_rd_ocd_data_ocd_st_DMb_EX_alw  : IN( ocd_data `EX` ) GRD( ocd_st_DMb `EX` ) OUT( dmb_wr `EX` )


      source code reference for conflict
      [ldst.n:67] dmb_wr `EX` = sxB `EX` = extract_w08 (sxW `EX` = s2 `EX`)  @sx;
        <>
      [ocd_if.n:66] DMb[dm_addr = ocd_addr_r] `EX` = dmb_wr `EX` = ocd_data `EX`;


      (refined) source code reference for conflict
      [ldst.n:67] dmb_wr `EX` = sxB `EX`
        <>
      [ocd_if.n:66] DMb[dm_addr = ocd_addr_r] `EX` = dmb_wr `EX` = ocd_data `EX`


dm_addr stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_copy0_aguC_ID  : IN( aguC `ID` ) OUT( dm_addr `ID` )
  <---> 
  dm_addr_copy0_ocd_addr_r_ocd_ld_DMb_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_ld_DMb `ID` ) OUT( dm_addr `ID` )


      source code reference for conflict
      [ldst.n:40] dm_addr `ID` = aguC `ID` = add (aguA `ID` = s0 `ID`, aguB `ID` = i `ID`)  @agu;
        <>
      [ocd_if.n:61] ocd_data `EX` = dmb_rd = DMb[dm_addr `ID` = ocd_addr_r `ID`] `EX`;


      (refined) source code reference for conflict
      [ldst.n:40] dm_addr `ID` = aguC `ID`
        <>
      [ocd_if.n:61] dm_addr `ID` = ocd_addr_r `ID`


dm_addr stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_copy0_aguA_ID  : IN( aguA `ID` ) OUT( dm_addr `ID` )
  <---> 
  dm_addr_copy0_ocd_addr_r_ocd_ld_DMb_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_ld_DMb `ID` ) OUT( dm_addr `ID` )


      source code reference for conflict
      [ldst.n:96] dm_addr `ID` = aguA `ID`;
        <>
      [ocd_if.n:61] ocd_data `EX` = dmb_rd = DMb[dm_addr `ID` = ocd_addr_r `ID`] `EX`;


      (refined) source code reference for conflict
      [ldst.n:96] dm_addr `ID` = aguA `ID`
        <>
      [ocd_if.n:61] dm_addr `ID` = ocd_addr_r `ID`


dm_addr stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_copy0_p_addr_EX  : IN( __p_addr_r `EX` ) OUT( dm_addr `EX` )
  <---> 
  dm_addr_copy0_ocd_addr_r_ocd_st_DMb_EX_alw  : IN( ocd_addr_r `EX` ) GRD( ocd_st_DMb `EX` ) OUT( dm_addr `EX` )


      source code reference for conflict
      [ldst.n:65] dm_addr `EX` = p_addr `EX`;
        <>
      [ocd_if.n:66] DMb[dm_addr = ocd_addr_r] `EX` = dmb_wr `EX` = ocd_data `EX`;


      (refined) source code reference for conflict
      [ldst.n:65] dm_addr `EX` = p_addr `EX`
        <>
      [ocd_if.n:66] dm_addr = ocd_addr_r


dmb_rd stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dmb_rd_ld_DMb_dm_addr_ID  : IN( DMb `EX` dm_addr `ID` ) OUT( dmb_rd `EX` )
  <---> 
  dmb_rd_ld_DMb_dm_addr_ocd_ld_DMb_ID_alw  : IN( DMb `EX` dm_addr `ID` ) GRD( ocd_ld_DMb `ID` ) OUT( dmb_rd `EX` )


      source code reference for conflict
      [ldst.n:43] dmb_rd `EX` = DMb[dm_addr `ID`] `EX`;
        <>
      [ocd_if.n:61] ocd_data `EX` = dmb_rd = DMb[dm_addr `ID` = ocd_addr_r `ID`] `EX`;


      (refined) source code reference for conflict
      [ldst.n:43] dmb_rd `EX` = DMb[dm_addr `ID`] `EX`
        <>
      [ocd_if.n:61] ocd_data `EX` = dmb_rd = DMb[dm_addr `ID` = ocd_addr_r `ID`] `EX`


ocd_addr_w stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_w_incr1_ocd_addr_r_ocd_addr_incr_ocd_ld_DMb_ID_alw  incr1: IN( ocd_addr_r `ID` ) GRD( ocd_ld_DMb `ID` ) OUT( ocd_addr_w `ID` ) @ ocd_addr_incr
  <---> 
  ocd_addr_w_incr1_ocd_addr_r_ocd_addr_incr_ocd_ld_PM_ID_alw  incr1: IN( ocd_addr_r `ID` ) GRD( ocd_ld_PM `ID` ) OUT( ocd_addr_w `ID` ) @ ocd_addr_incr

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:59] ocd_addr `ID` = ocd_addr_w `ID` = incr1 (ocd_addr_r `ID` = ocd_addr `ID`)  @ocd_addr_incr;
        <>
      [ocd_if.n:73] ocd_addr `ID` = ocd_addr_w `ID` = incr1 (ocd_addr_r `ID` = ocd_addr `ID`)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:59] ocd_addr `ID` = ocd_addr_w `ID`
        <>
      [ocd_if.n:73] ocd_addr `ID` = ocd_addr_w `ID`


ocd_addr_w stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_w_incr1_ocd_addr_r_ocd_addr_incr_ocd_st_DMb_EX_alw  incr1: IN( ocd_addr_r `EX` ) GRD( ocd_st_DMb `EX` ) OUT( ocd_addr_w `EX` ) @ ocd_addr_incr
  <---> 
  ocd_addr_w_incr1_ocd_addr_r_ocd_addr_incr_ocd_st_PM_EX_alw  incr1: IN( ocd_addr_r `EX` ) GRD( ocd_st_PM `EX` ) OUT( ocd_addr_w `EX` ) @ ocd_addr_incr

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:65] ocd_addr `EX` = ocd_addr_w `EX` = incr1 (ocd_addr_r `EX` = ocd_addr `EX`)  @ocd_addr_incr;
        <>
      [ocd_if.n:79] ocd_addr `EX` = ocd_addr_w `EX` = incr1 (ocd_addr_r `EX` = ocd_addr `EX`)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:65] ocd_addr `EX` = ocd_addr_w `EX`
        <>
      [ocd_if.n:79] ocd_addr `EX` = ocd_addr_w `EX`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_DMb_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_DMb `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_ld_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_PM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:59] ocd_addr `ID` = ocd_addr_w `ID` = incr1 (ocd_addr_r `ID` = ocd_addr `ID`)  @ocd_addr_incr;
        <>
      [ocd_if.n:73] ocd_addr `ID` = ocd_addr_w `ID` = incr1 (ocd_addr_r `ID` = ocd_addr `ID`)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:59] ocd_addr_r `ID` = ocd_addr `ID`
        <>
      [ocd_if.n:73] ocd_addr_r `ID` = ocd_addr `ID`


ocd_addr_r stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_st_DMb_EX_alw  : IN( ocd_addr `EX` ) GRD( ocd_st_DMb `EX` ) OUT( ocd_addr_r `EX` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_st_PM_EX_alw  : IN( ocd_addr `EX` ) GRD( ocd_st_PM `EX` ) OUT( ocd_addr_r `EX` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:65] ocd_addr `EX` = ocd_addr_w `EX` = incr1 (ocd_addr_r `EX` = ocd_addr `EX`)  @ocd_addr_incr;
        <>
      [ocd_if.n:79] ocd_addr `EX` = ocd_addr_w `EX` = incr1 (ocd_addr_r `EX` = ocd_addr `EX`)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:65] ocd_addr_r `EX` = ocd_addr `EX`
        <>
      [ocd_if.n:79] ocd_addr_r `EX` = ocd_addr `EX`

