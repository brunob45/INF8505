
// File generated by pdg version N-2018.03#7d02e3ca79#180723, Thu Feb 28 14:33:26 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// pdg -P -B -Iisg +wisg -I../../io_modules -I/CMC/tools/synopsys/asip_designer_vN-2018.03-SP3/linux64/chessdir/../examples/io_modules -D__tct_patch__=300 -D__checkers__ tlx

#ifndef TLX_INLINE_PRIMITIVES_H
#define TLX_INLINE_PRIMITIVES_H

#ifdef __checkers__
#include "Mdl_tlx.h"

#include "checkers_errors.h"
#endif // __checkers__

#include <sstream>

#include <iostream>
#include <cstdlib>
#ifndef PDG_NATIVE_HANDLE_ERR
#define PDG_NATIVE_HANDLE_ERR(msg, loc) \
  std::cerr << "An error occurred: " << msg << " at: " << loc << std::endl; \
  std::cerr << "Exiting.." << std::endl; \
  exit(1);
#endif

#ifndef PDG_NATIVE_HANDLE_WRN
#define PDG_NATIVE_HANDLE_WRN(msg, loc) \
  std::cerr << "Warning: " << msg << " at: " << loc << std::endl;
#endif

namespace tlx_primitive {

    const int controller_module_id = 0;
    const int banks_module_id = 1;

    inline tlx_primitive::w32 add(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::uint1& co) {
        VBit<33, false> aa = VBit<33, false>(VBit<32, false>(a.val));
        VBit<33, false> bb = VBit<33, false>(VBit<32, false>(b.val));
        VBit<33, false> rr = (aa + bb);
        co = rr.extract(0x20u);
        return tlx_primitive::w32(VBit<32, false>(rr.extract(0x1Fu, 0x0u)));
    }

    inline tlx_primitive::w32 add(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return (a.val + b.val);
    }

    inline tlx_primitive::w32 sub(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::uint1& co) {
        VBit<33, false> aa = VBit<33, false>(VBit<32, false>(a.val));
        VBit<33, false> bb = VBit<33, false>(VBit<32, false>(b.val));
        VBit<33, false> rr = (aa - bb);
        co = rr.extract(0x20u);
        return tlx_primitive::w32(VBit<32, false>(rr.extract(0x1Fu, 0x0u)));
    }

    inline tlx_primitive::w32 addx(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::uint1 ci, tlx_primitive::uint1& co) {
        VBit<33, false> aa = VBit<33, false>(VBit<32, false>(a.val));
        VBit<33, false> bb = VBit<33, false>(VBit<32, false>(b.val));
        VBit<33, false> rr = ((aa + bb) + VBit<33, false>(ci.val));
        co = rr.extract(0x20u);
        return tlx_primitive::w32(VBit<32, false>(rr.extract(0x1Fu, 0x0u)));
    }

    inline tlx_primitive::w32 subx(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::uint1 ci, tlx_primitive::uint1& co) {
        VBit<33, false> aa = VBit<33, false>(VBit<32, false>(a.val));
        VBit<33, false> bb = VBit<33, false>(VBit<32, false>(b.val));
        VBit<33, false> rr = ((aa - bb) - VBit<33, false>(ci.val));
        co = rr.extract(0x20u);
        return tlx_primitive::w32(VBit<32, false>(rr.extract(0x1Fu, 0x0u)));
    }

    inline tlx_primitive::w32 band(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return (a.val & b.val);
    }

    inline tlx_primitive::w32 bor(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return (a.val | b.val);
    }

    inline tlx_primitive::w32 bxor(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return (a.val ^ b.val);
    }

    inline tlx_primitive::w32 sge(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val >= b.val));
    }

    inline tlx_primitive::w32 sgt(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val > b.val));
    }

    inline tlx_primitive::w32 sle(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val <= b.val));
    }

    inline tlx_primitive::w32 slt(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val < b.val));
    }

    inline tlx_primitive::w32 seq(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val == b.val));
    }

    inline tlx_primitive::w32 sne(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val != b.val));
    }

    inline tlx_primitive::w32 sgeu(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((VBit<32, false>(a.val) >= VBit<32, false>(b.val)));
    }

    inline tlx_primitive::w32 sgtu(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((VBit<32, false>(a.val) > VBit<32, false>(b.val)));
    }

    inline tlx_primitive::w32 sleu(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((VBit<32, false>(a.val) <= VBit<32, false>(b.val)));
    }

    inline tlx_primitive::w32 sltu(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((VBit<32, false>(a.val) < VBit<32, false>(b.val)));
    }

    inline tlx_primitive::w32 sra(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return (a.val >> VBit<5, false>(VBit<5, true>(b.val.extract(0x4u, 0x0u))));
    }

    inline tlx_primitive::w32 sll(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((VBit<32, false>(a.val) << VBit<5, false>(VBit<5, true>(b.val.extract(0x4u, 0x0u)))));
    }

    inline tlx_primitive::w32 srl(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((VBit<32, false>(a.val) >> VBit<5, false>(VBit<5, true>(b.val.extract(0x4u, 0x0u)))));
    }

    inline tlx_primitive::w32 xtd(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        VBit<5, false> f = VBit<5, false>((VBit<32, true>(0x20) - b.val));
        return ((a.val << f) >> f);
    }

    inline tlx_primitive::w32 mul(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return tlx_primitive::w32((a.val * b.val));
    }

    inline void lmulss(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::w32& lo, tlx_primitive::w32& hi) {
        VBit<64, true> p = (a.val * b.val);
        lo = VBit<32, true>(p.extract(0x1Fu, 0x0u));
        hi = VBit<32, true>(p.extract(0x3Fu, 0x20u));
    }

    inline void lmulsu(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::w32& lo, tlx_primitive::w32& hi) {
        VBit<64, true> p = (a.val * VBit<32, false>(b.val));
        lo = VBit<32, true>(p.extract(0x1Fu, 0x0u));
        hi = VBit<32, true>(p.extract(0x3Fu, 0x20u));
    }

    inline void lmuluu(tlx_primitive::w32 a, tlx_primitive::w32 b, tlx_primitive::w32& lo, tlx_primitive::w32& hi) {
        VBit<64, true> p = VBit<64, true>((VBit<32, false>(a.val) * VBit<32, false>(b.val)));
        lo = VBit<32, true>(p.extract(0x1Fu, 0x0u));
        hi = VBit<32, true>(p.extract(0x3Fu, 0x20u));
    }

    inline tlx_primitive::w32 clb(tlx_primitive::w32 a) {
        VBit<6, false> r;
        tlx_primitive::w32 t;
        if ((a.val < 0x0)) {
            t = ~a.val;
        } else {
            t = a.val;
        }
        tlx_primitive::w32 tmp = t.val;
        if ((VBit<32, true>(tmp.val.extract(0x1Fu, 0x0u)) == 0x0)) {
            r = 0x20u;
        } else if ((VBit<31, true>(tmp.val.extract(0x1Fu, 0x1u)) == 0x0)) {
            r = 0x1Fu;
        } else if ((VBit<30, true>(tmp.val.extract(0x1Fu, 0x2u)) == 0x0)) {
            r = 0x1Eu;
        } else if ((VBit<29, true>(tmp.val.extract(0x1Fu, 0x3u)) == 0x0)) {
            r = 0x1Du;
        } else if ((VBit<28, true>(tmp.val.extract(0x1Fu, 0x4u)) == 0x0)) {
            r = 0x1Cu;
        } else if ((VBit<27, true>(tmp.val.extract(0x1Fu, 0x5u)) == 0x0)) {
            r = 0x1Bu;
        } else if ((VBit<26, true>(tmp.val.extract(0x1Fu, 0x6u)) == 0x0)) {
            r = 0x1Au;
        } else if ((VBit<25, true>(tmp.val.extract(0x1Fu, 0x7u)) == 0x0)) {
            r = 0x19u;
        } else if ((VBit<24, true>(tmp.val.extract(0x1Fu, 0x8u)) == 0x0)) {
            r = 0x18u;
        } else if ((VBit<23, true>(tmp.val.extract(0x1Fu, 0x9u)) == 0x0)) {
            r = 0x17u;
        } else if ((VBit<22, true>(tmp.val.extract(0x1Fu, 0xAu)) == 0x0)) {
            r = 0x16u;
        } else if ((VBit<21, true>(tmp.val.extract(0x1Fu, 0xBu)) == 0x0)) {
            r = 0x15u;
        } else if ((VBit<20, true>(tmp.val.extract(0x1Fu, 0xCu)) == 0x0)) {
            r = 0x14u;
        } else if ((VBit<19, true>(tmp.val.extract(0x1Fu, 0xDu)) == 0x0)) {
            r = 0x13u;
        } else if ((VBit<18, true>(tmp.val.extract(0x1Fu, 0xEu)) == 0x0)) {
            r = 0x12u;
        } else if ((VBit<17, true>(tmp.val.extract(0x1Fu, 0xFu)) == 0x0)) {
            r = 0x11u;
        } else if ((VBit<16, true>(tmp.val.extract(0x1Fu, 0x10u)) == 0x0)) {
            r = 0x10u;
        } else if ((VBit<15, true>(tmp.val.extract(0x1Fu, 0x11u)) == 0x0)) {
            r = 0xFu;
        } else if ((VBit<14, true>(tmp.val.extract(0x1Fu, 0x12u)) == 0x0)) {
            r = 0xEu;
        } else if ((VBit<13, true>(tmp.val.extract(0x1Fu, 0x13u)) == 0x0)) {
            r = 0xDu;
        } else if ((VBit<12, true>(tmp.val.extract(0x1Fu, 0x14u)) == 0x0)) {
            r = 0xCu;
        } else if ((VBit<11, true>(tmp.val.extract(0x1Fu, 0x15u)) == 0x0)) {
            r = 0xBu;
        } else if ((VBit<10, true>(tmp.val.extract(0x1Fu, 0x16u)) == 0x0)) {
            r = 0xAu;
        } else if ((VBit<9, true>(tmp.val.extract(0x1Fu, 0x17u)) == 0x0)) {
            r = 0x9u;
        } else if ((VBit<8, true>(tmp.val.extract(0x1Fu, 0x18u)) == 0x0)) {
            r = 0x8u;
        } else if ((VBit<7, true>(tmp.val.extract(0x1Fu, 0x19u)) == 0x0)) {
            r = 0x7u;
        } else if ((VBit<6, true>(tmp.val.extract(0x1Fu, 0x1Au)) == 0x0)) {
            r = 0x6u;
        } else if ((VBit<5, true>(tmp.val.extract(0x1Fu, 0x1Bu)) == 0x0)) {
            r = 0x5u;
        } else if ((VBit<4, true>(tmp.val.extract(0x1Fu, 0x1Cu)) == 0x0)) {
            r = 0x4u;
        } else if ((VBit<3, true>(tmp.val.extract(0x1Fu, 0x1Du)) == 0x0)) {
            r = 0x3u;
        } else if ((VBit<2, true>(tmp.val.extract(0x1Fu, 0x1Eu)) == 0x0)) {
            r = 0x2u;
        } else {
            r = 0x1u;
        }
        return tlx_primitive::w32(r);
    }

    inline tlx_primitive::w32 extend_sign(tlx_primitive::w08 a) {
        return tlx_primitive::w32(a.val);
    }

    inline tlx_primitive::w32 extend_zero(tlx_primitive::w08 a) {
        return tlx_primitive::w32(VBit<8, false>(a.val));
    }

    inline tlx_primitive::w32 extend_sign(tlx_primitive::w16 a) {
        return tlx_primitive::w32(a.val);
    }

    inline tlx_primitive::w32 extend_zero(tlx_primitive::w16 a) {
        return tlx_primitive::w32(VBit<16, false>(a.val));
    }

    inline tlx_primitive::w08 extract_w08(tlx_primitive::w32 a) {
        return VBit<8, true>(a.val.extract(0x7u, 0x0u));
    }

    inline tlx_primitive::w16 extract_w16(tlx_primitive::w32 a) {
        return VBit<16, true>(a.val.extract(0xFu, 0x0u));
    }

    inline bool eqz(tlx_primitive::w32 a) {
        return (a.val == 0x0);
    }

    inline bool nez(tlx_primitive::w32 a) {
        return (a.val != 0x0);
    }

    inline void nop() {
    }

    inline tlx_primitive::w32 pcadd(tlx_primitive::w32 a, tlx_primitive::w32 b) {
        return (a.val + b.val);
    }

    inline void sha256_ci(tlx_primitive::w32 ai, tlx_primitive::w32 bi, tlx_primitive::w32 ci, tlx_primitive::w32 di, tlx_primitive::w32 ei, tlx_primitive::w32 fi, tlx_primitive::w32 gi, tlx_primitive::w32 hi, tlx_primitive::w32 ki, tlx_primitive::w32 mi, tlx_primitive::w32& ao, tlx_primitive::w32& bo, tlx_primitive::w32& co, tlx_primitive::w32& d2, tlx_primitive::w32& eo, tlx_primitive::w32& fo, tlx_primitive::w32& go, tlx_primitive::w32& ho) {
        VBit<32, false> a = VBit<32, false>(ai.val);
        VBit<32, false> b = VBit<32, false>(bi.val);
        VBit<32, false> c = VBit<32, false>(ci.val);
        VBit<32, false> d = VBit<32, false>(di.val);
        VBit<32, false> e = VBit<32, false>(ei.val);
        VBit<32, false> f = VBit<32, false>(fi.val);
        VBit<32, false> g = VBit<32, false>(gi.val);
        VBit<32, false> h = VBit<32, false>(hi.val);
        VBit<32, false> k = VBit<32, false>(ki.val);
        VBit<32, false> m = VBit<32, false>(mi.val);
        VBit<32, false> t1 = ((((h + ((((e >> 0x6u) | (e << 0x1Au)) ^ ((e >> 0xBu) | (e << 0x15u))) ^ ((e >> 0x19u) | (e << 0x7u)))) + ((e & f) ^ (~e & g))) + k) + m);
        VBit<32, false> t2 = (((((a >> 0x2u) | (a << 0x1Eu)) ^ ((a >> 0xDu) | (a << 0x13u))) ^ ((a >> 0x16u) | (a << 0xAu))) + (((a & b) ^ (a & c)) ^ (b & c)));
        ho = tlx_primitive::w32(g).val;
        go = tlx_primitive::w32(f).val;
        fo = tlx_primitive::w32(e).val;
        eo = tlx_primitive::w32((d + t1)).val;
        d2 = tlx_primitive::w32(c).val;
        co = tlx_primitive::w32(b).val;
        bo = tlx_primitive::w32(a).val;
        ao = tlx_primitive::w32((t1 + t2)).val;
    }

    inline tlx_primitive::w32 sha256_in1(tlx_primitive::w32 ai, tlx_primitive::w32 bi, tlx_primitive::w32 ci, tlx_primitive::w32 di) {
        VBit<32, false> a = VBit<32, false>(ai.val);
        VBit<32, false> b = VBit<32, false>(bi.val);
        VBit<32, false> c = VBit<32, false>(ci.val);
        VBit<32, false> d = VBit<32, false>(di.val);
        return tlx_primitive::w32((((((((a >> 0x11u) | (a << 0xFu)) ^ ((a >> 0x13u) | (a << 0xDu))) ^ (a >> 0xAu)) + b) + ((((c >> 0x7u) | (c << 0x19u)) ^ ((c >> 0x12u) | (c << 0xEu))) ^ (c >> 0x3u))) + d));
    }

    inline tlx_primitive::w32 sha256_in2(tlx_primitive::w32 ai, tlx_primitive::w32 bi, tlx_primitive::w32 ci, tlx_primitive::w32 di) {
        VBit<32, false> a = VBit<32, false>(ai.val);
        VBit<32, false> b = VBit<32, false>(bi.val);
        VBit<32, false> c = VBit<32, false>(ci.val);
        VBit<32, false> d = VBit<32, false>(di.val);
        return tlx_primitive::w32(((((a << 0x18u) | (b << 0x10u)) | (c << 0x8u)) | d));
    }

#ifdef __checkers__
    class banks {
    public:
        banks(tlx* p) : mdl(p) {}

#ifdef __checkers__
        void process_result() {
            mdl->dmw_rd.write(tlx_primitive::w32(concat(mdl->dm0_rd.read().val, mdl->dm1_rd.read().val, mdl->dm2_rd.read().val, mdl->dm3_rd.read().val)));
            if ((mdl->banks__ld0_ff.pdgValue()).to_bool()) {
                mdl->dmh_rd.write(tlx_primitive::w16(concat(mdl->dm0_rd.read().val, mdl->dm1_rd.read().val)));
            } else if ((mdl->banks__ld2_ff.pdgValue()).to_bool()) {
                mdl->dmh_rd.write(tlx_primitive::w16(concat(mdl->dm2_rd.read().val, mdl->dm3_rd.read().val)));
            }
            if ((mdl->banks__ld0_ff.pdgValue()).to_bool()) {
                mdl->dmb_rd.write(mdl->dm0_rd.read());
            } else if ((mdl->banks__ld1_ff.pdgValue()).to_bool()) {
                mdl->dmb_rd.write(mdl->dm1_rd.read());
            } else if ((mdl->banks__ld2_ff.pdgValue()).to_bool()) {
                mdl->dmb_rd.write(mdl->dm2_rd.read());
            } else if ((mdl->banks__ld3_ff.pdgValue()).to_bool()) {
                mdl->dmb_rd.write(mdl->dm3_rd.read());
            }
        }

#endif // __checkers__

        void process_request();

#ifdef __checkers__
        void update_status() {
            mdl->banks__ld0_ff.update(1);
            mdl->banks__ld1_ff.update(1);
            mdl->banks__ld2_ff.update(1);
            mdl->banks__ld3_ff.update(1);
        }

#endif // __checkers__

#ifdef __checkers__
        void clear_update() {
            mdl->banks__ld0_ff.clear_update();
            mdl->banks__ld1_ff.clear_update();
            mdl->banks__ld2_ff.clear_update();
            mdl->banks__ld3_ff.clear_update();
        }

#endif // __checkers__

        void dbg_access_DMb(unsigned a, tlx_primitive::w08& v, bool read) {
            if ((VBit<2, false>(VBit<32, false>(a).extract(0x1u, 0x0u)) == 0x0u)) {
                dbg_access_DM0((VBit<30, false>(VBit<32, false>(a).extract(0x1Fu, 0x2u))).to_unsigned(), v, read);
            } else if ((VBit<2, false>(VBit<32, false>(a).extract(0x1u, 0x0u)) == 0x1u)) {
                dbg_access_DM1((VBit<30, false>(VBit<32, false>(a).extract(0x1Fu, 0x2u))).to_unsigned(), v, read);
            } else if ((VBit<2, false>(VBit<32, false>(a).extract(0x1u, 0x0u)) == 0x2u)) {
                dbg_access_DM2((VBit<30, false>(VBit<32, false>(a).extract(0x1Fu, 0x2u))).to_unsigned(), v, read);
            } else if ((VBit<2, false>(VBit<32, false>(a).extract(0x1u, 0x0u)) == 0x3u)) {
                dbg_access_DM3((VBit<30, false>(VBit<32, false>(a).extract(0x1Fu, 0x2u))).to_unsigned(), v, read);
            }
        }

        void dbg_access_DM0(AddressType dbg_addr, tlx_primitive::w08& dbg_val, bool dbg_read);

        void dbg_access_DM1(AddressType dbg_addr, tlx_primitive::w08& dbg_val, bool dbg_read);

        void dbg_access_DM2(AddressType dbg_addr, tlx_primitive::w08& dbg_val, bool dbg_read);

        void dbg_access_DM3(AddressType dbg_addr, tlx_primitive::w08& dbg_val, bool dbg_read);

    private:
        tlx* mdl;
    };

#endif // __checkers__

} // namespace tlx_primitive
#endif
