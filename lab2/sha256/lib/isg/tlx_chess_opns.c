
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Thu Feb 28 14:33:23 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -Pc -B -Iisg +wisg -I../../io_modules -I/CMC/tools/synopsys/asip_designer_vN-2018.03-SP3/linux64/chessdir/../examples/io_modules -D__tct_patch__=300 -D__chess__ -D__programmers_view__ tlx

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Native equivalent of Chess promoted operations

#include "tlx_iss_types.h"
#include "tlx_chess_types.h"
#include "tlx_inline_primitives.h"
#include "tlx_chess_opns.h"

#ifndef CHESS_NATIVE_LINKAGE
#define CHESS_NATIVE_LINKAGE
#endif

CHESS_NATIVE_LINKAGE bool land(bool a0, bool a1)
{
    tlx_primitive::w32 p0 = tlx_primitive::__promo_bool_on_w32(a0);
    tlx_primitive::w32 p1 = tlx_primitive::__promo_bool_on_w32(a1);
    tlx_primitive::w32 t = tlx_primitive::band(p0, p1);
    bool r; r = tlx_primitive::__promo_w32_to_bool(t);
    return r;
}

CHESS_NATIVE_LINKAGE bool lor(bool a0, bool a1)
{
    tlx_primitive::w32 p0 = tlx_primitive::__promo_bool_on_w32(a0);
    tlx_primitive::w32 p1 = tlx_primitive::__promo_bool_on_w32(a1);
    tlx_primitive::w32 t = tlx_primitive::bor(p0, p1);
    bool r; r = tlx_primitive::__promo_w32_to_bool(t);
    return r;
}

CHESS_NATIVE_LINKAGE bool lxor(bool a0, bool a1)
{
    tlx_primitive::w32 p0 = tlx_primitive::__promo_bool_on_w32(a0);
    tlx_primitive::w32 p1 = tlx_primitive::__promo_bool_on_w32(a1);
    tlx_primitive::w32 t = tlx_primitive::bxor(p0, p1);
    bool r; r = tlx_primitive::__promo_w32_to_bool(t);
    return r;
}

CHESS_NATIVE_LINKAGE bool nez(int a0)
{
    tlx_primitive::w32 p0 = a0;
    bool t = tlx_primitive::nez(p0);
    bool r; r = t;
    return r;
}

CHESS_NATIVE_LINKAGE bool eqz(int a0)
{
    tlx_primitive::w32 p0 = a0;
    bool t = tlx_primitive::eqz(p0);
    bool r; r = t;
    return r;
}

CHESS_NATIVE_LINKAGE bool nez(unsigned a0)
{
    tlx_primitive::w32 p0 = a0;
    bool t = tlx_primitive::nez(p0);
    bool r; r = t;
    return r;
}

CHESS_NATIVE_LINKAGE bool eqz(unsigned a0)
{
    tlx_primitive::w32 p0 = a0;
    bool t = tlx_primitive::eqz(p0);
    bool r; r = t;
    return r;
}

#if 0//!
CHESS_NATIVE_LINKAGE bool nez(void * a0)
{
    tlx_primitive::w32 p0 = a0;
    bool t = tlx_primitive::nez(p0);
    bool r; r = t;
    return r;
}
#endif//!

#if 0//!
CHESS_NATIVE_LINKAGE bool eqz(void * a0)
{
    tlx_primitive::w32 p0 = a0;
    bool t = tlx_primitive::eqz(p0);
    bool r; r = t;
    return r;
}
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint to_dint_se(int i)
    {
     return dint(i >> 31,i);
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint to_dint_ze(int i)
    {
     return dint(0,i);
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE int to_int(dint w)
    {
     return w.low;
    }
} //namespace tlx_primitive
#endif//!

namespace tlx_primitive{
CHESS_NATIVE_LINKAGE unsigned add(unsigned a0, unsigned a1, uint1 & a2)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2; //output
    w32 t = add(p0, p1, p2);
    a2 = p2;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace tlx_primitive

namespace tlx_primitive{
CHESS_NATIVE_LINKAGE unsigned sub(unsigned a0, unsigned a1, uint1 & a2)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2; //output
    w32 t = sub(p0, p1, p2);
    a2 = p2;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace tlx_primitive

namespace tlx_primitive{
CHESS_NATIVE_LINKAGE unsigned addx(unsigned a0, unsigned a1, uint1 a2, uint1 & a3)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2 = a2;
    uint1 p3; //output
    w32 t = addx(p0, p1, p2, p3);
    a3 = p3;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace tlx_primitive

namespace tlx_primitive{
CHESS_NATIVE_LINKAGE unsigned subx(unsigned a0, unsigned a1, uint1 a2, uint1 & a3)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2 = a2;
    uint1 p3; //output
    w32 t = subx(p0, p1, p2, p3);
    a3 = p3;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace tlx_primitive

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_add(dint a, dint b)
    {
     dint r;
     uint1 carry; uint1 carry2;
     if (chess_manifest(a.low == 0))
      {
       r.low = b.low;
       r.high = a.high + b.high;
      }
     else
      if (chess_manifest(b.low == 0))
       {
        r.low = a.low;
        r.high = a.high + b.high;
       }
      else
       {
        r.low = add(a.low,b.low,carry);
        r.high = addx(a.high,b.high,carry,carry2);
       }
     return r;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_sub(dint a, dint b)
    {
     dint r;
     uint1 borrow; uint1 borrow2;
     if (chess_manifest(b.low == 0))
      {
       r.low = a.low;
       r.high = a.high - b.high;
      }
     else
      {
       r.low = sub(a.low,b.low,borrow);
       r.high = subx(a.high,b.high,borrow,borrow2);
      }
     return r;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_and(dint a, dint b)
    {
     return dint(a.high & b.high,a.low & b.low);
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_or(dint a, dint b)
    {
     return dint(a.high | b.high,a.low | b.low);
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_xor(dint a, dint b)
    {
     return dint(a.high ^ b.high,a.low ^ b.low);
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_complement(dint a)
    {
     return dint(~a.high,~a.low);
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_lts(dint a, dint b)
    {
     if ((int)a.high < (int)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low < b.low;
      else
       return false;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_les(dint a, dint b)
    {
     if ((int)a.high < (int)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low <= b.low;
      else
       return false;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_ltu(dint a, dint b)
    {
     if ((unsigned)a.high < (unsigned)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low < b.low;
      else
       return false;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_leu(dint a, dint b)
    {
     if ((unsigned)a.high < (unsigned)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low <= b.low;
      else
       return false;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_eq(dint a, dint b)
    {
     return a.high == b.high && a.low == b.low;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_ne(dint a, dint b)
    {
     return a.high != b.high || a.low != b.low;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_lsl(dint a, int f)
    {
     unsigned carries;
     dint r;
     if (f == 0)
      return a;
     else
      ;
     if (f < 32)
      {
       carries = a.low >> 32 - f;
       r.low = chess_dont_warn_range(a.low << f);
       r.high = chess_dont_warn_range(a.high << f) | carries;
      }
     else
      {
       carries = a.low << f - 32;
       r.low = 0;
       r.high = carries;
      }
     return r;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_asr(dint a, int f)
    {
     unsigned carries;
     dint r;
     if (f == 0)
      return a;
     else
      ;
     if (f < 32)
      {
       carries = a.high << 32 - f;
       r.low = chess_dont_warn_range(a.low >> f) | carries;
       r.high = chess_dont_warn_range((int)a.high >> f);
      }
     else
      {
       carries = (int)a.high >> f - 32;
       r.low = carries;
       r.high = (int)carries >> 31;
      }
     return r;
    }
} //namespace tlx_primitive
#endif//!

#if 0//!
namespace tlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_lsr(dint a, int f)
    {
     unsigned carries;
     dint r;
     if (f == 0)
      return a;
     else
      ;
     if (f < 32)
      {
       carries = a.high << 32 - f;
       r.low = chess_dont_warn_range(a.low >> f) | carries;
       r.high = chess_dont_warn_range(a.high >> f);
      }
     else
      {
       carries = a.high >> f - 32;
       r.low = carries;
       r.high = 0;
      }
     return r;
    }
} //namespace tlx_primitive
#endif//!

CHESS_NATIVE_LINKAGE void sha256_ci(unsigned a0, unsigned a1, unsigned a2, unsigned a3, unsigned a4, unsigned a5, unsigned a6, unsigned a7, unsigned a8, unsigned a9, unsigned & a10, unsigned & a11, unsigned & a12, unsigned & a13, unsigned & a14, unsigned & a15, unsigned & a16, unsigned & a17)
{
    tlx_primitive::w32 p0 = a0;
    tlx_primitive::w32 p1 = a1;
    tlx_primitive::w32 p2 = a2;
    tlx_primitive::w32 p3 = a3;
    tlx_primitive::w32 p4 = a4;
    tlx_primitive::w32 p5 = a5;
    tlx_primitive::w32 p6 = a6;
    tlx_primitive::w32 p7 = a7;
    tlx_primitive::w32 p8 = a8;
    tlx_primitive::w32 p9 = a9;
    tlx_primitive::w32 p10; //output
    tlx_primitive::w32 p11; //output
    tlx_primitive::w32 p12; //output
    tlx_primitive::w32 p13; //output
    tlx_primitive::w32 p14; //output
    tlx_primitive::w32 p15; //output
    tlx_primitive::w32 p16; //output
    tlx_primitive::w32 p17; //output
    tlx_primitive::sha256_ci(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17);
    a10 = toVBit(p10).value();
    a11 = toVBit(p11).value();
    a12 = toVBit(p12).value();
    a13 = toVBit(p13).value();
    a14 = toVBit(p14).value();
    a15 = toVBit(p15).value();
    a16 = toVBit(p16).value();
    a17 = toVBit(p17).value();
}

CHESS_NATIVE_LINKAGE unsigned sha256_in1(unsigned a0, unsigned a1, unsigned a2, unsigned a3)
{
    tlx_primitive::w32 p0 = a0;
    tlx_primitive::w32 p1 = a1;
    tlx_primitive::w32 p2 = a2;
    tlx_primitive::w32 p3 = a3;
    tlx_primitive::w32 t = tlx_primitive::sha256_in1(p0, p1, p2, p3);
    unsigned r; r = toVBit(t).value();
    return r;
}

CHESS_NATIVE_LINKAGE unsigned sha256_in2(unsigned a0, unsigned a1, unsigned a2, unsigned a3)
{
    tlx_primitive::w32 p0 = a0;
    tlx_primitive::w32 p1 = a1;
    tlx_primitive::w32 p2 = a2;
    tlx_primitive::w32 p3 = a3;
    tlx_primitive::w32 t = tlx_primitive::sha256_in2(p0, p1, p2, p3);
    unsigned r; r = toVBit(t).value();
    return r;
}



// composed promotion conversions
#ifndef do_not_generate_composed_promo_cnvs /*trouble-shooting hook*/
namespace tlx_primitive {
    CHESS_NATIVE_LINKAGE w32 __promo_bool_on_w32(bool a)
        { return w32::BitType(a); }
    CHESS_NATIVE_LINKAGE bool __promo_w32_to_bool(w32 a)
        { return toVBit(a).value(); }
} //namespace tlx_primitive
#endif /*!do_not_generate_composed_promo_cnvs*/

