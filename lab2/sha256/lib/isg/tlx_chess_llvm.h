
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Thu Feb 28 14:33:23 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -Pc -B -Iisg +wisg -I../../io_modules -I/CMC/tools/synopsys/asip_designer_vN-2018.03-SP3/linux64/chessdir/../examples/io_modules -D__tct_patch__=300 -D__chess__ -D__programmers_view__ tlx

#ifndef _tlx_chess_llvm_h
#define _tlx_chess_llvm_h

#pragma clang diagnostic error "-Wpointer-arith"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
#pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
#pragma clang diagnostic ignored "-Wshift-op-parentheses"
#pragma clang diagnostic ignored "-Wunused-private-field"

enum chessllvmInternal { chessllvm_reinterpret }; //overloading hook

#ifdef __cplusplus
template <class T> struct chessllvm_remove_cv { typedef T type; };
template <class T> struct chessllvm_remove_cv<const T> { typedef T type; };
template <class T> struct chessllvm_remove_cv<volatile T> { typedef T type; };
template <class T> struct chessllvm_remove_cv<const volatile T> { typedef T type; };
template <class T> struct chessllvm_remove_reference { typedef T type; };
template <class T> struct chessllvm_remove_reference<T&> { typedef T type; };
template <class T> struct chessllvm_remove_reference<T&&> { typedef T type; };
#endif

#ifdef __cplusplus
#define __C__ "C"
#if __cplusplus >= 201103L
#define __STUB_DEFAULT__ = default;
#else
#define __STUB_DEFAULT__ {}
#endif
#else
#define asm __asm__
#define bool _Bool
#define __C__ /**/
#endif

void chess_report(bool)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(char)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(signed char)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned char)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(short)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned short)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(int)                  __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned int)         __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(long)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned long)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(long long)            __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(unsigned long long)   __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(float)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(double)               __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(long double)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_report(const volatile void*) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));

void chess_assert(bool)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(char)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(signed char)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned char)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(short)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned short)       __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(int)                  __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned int)         __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(long)                 __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned long)        __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(long long)            __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(unsigned long long)   __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(float)                __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(double)               __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(long double)          __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));
void chess_assert(const volatile void*) __attribute__((overloadable)) __attribute__((chess_inaccessiblememonly));

#ifdef __cplusplus
template <typename T>
T chess_copy(T a)       __attribute__((const)) __attribute__((nocse));
template <typename T>
T chess_dont_chain(T a) __attribute__((const));
template <typename T>
T chess_keep_dead(T a);
#else
bool                 chess_copy      (bool)                 __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
char                 chess_copy      (char)                 __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
signed char          chess_copy      (signed char)          __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned char        chess_copy      (unsigned char)        __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
short                chess_copy      (short)                __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned short       chess_copy      (unsigned short)       __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
int                  chess_copy      (int)                  __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned int         chess_copy      (unsigned int)         __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
long                 chess_copy      (long)                 __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned long        chess_copy      (unsigned long)        __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
long long            chess_copy      (long long)            __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
unsigned long long   chess_copy      (unsigned long long)   __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
float                chess_copy      (float)                __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
double               chess_copy      (double)               __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
long double          chess_copy      (long double)          __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse));
void*                chess_copy      (void*)                __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
const void*          chess_copy      (const void*)          __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
volatile void*       chess_copy      (volatile void*)       __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
const volatile void* chess_copy      (const volatile void*) __attribute__((overloadable)) __attribute__((const)) __attribute__((nocse)); //BUG does not preserve complete type
bool                 chess_dont_chain(bool)                 __attribute__((overloadable)) __attribute__((const));
char                 chess_dont_chain(char)                 __attribute__((overloadable)) __attribute__((const));
signed char          chess_dont_chain(signed char)          __attribute__((overloadable)) __attribute__((const));
unsigned char        chess_dont_chain(unsigned char)        __attribute__((overloadable)) __attribute__((const));
short                chess_dont_chain(short)                __attribute__((overloadable)) __attribute__((const));
unsigned short       chess_dont_chain(unsigned short)       __attribute__((overloadable)) __attribute__((const));
int                  chess_dont_chain(int)                  __attribute__((overloadable)) __attribute__((const));
unsigned int         chess_dont_chain(unsigned int)         __attribute__((overloadable)) __attribute__((const));
long                 chess_dont_chain(long)                 __attribute__((overloadable)) __attribute__((const));
unsigned long        chess_dont_chain(unsigned long)        __attribute__((overloadable)) __attribute__((const));
long long            chess_dont_chain(long long)            __attribute__((overloadable)) __attribute__((const));
unsigned long long   chess_dont_chain(unsigned long long)   __attribute__((overloadable)) __attribute__((const));
float                chess_dont_chain(float)                __attribute__((overloadable)) __attribute__((const));
double               chess_dont_chain(double)               __attribute__((overloadable)) __attribute__((const));
long double          chess_dont_chain(long double)          __attribute__((overloadable)) __attribute__((const));
void*                chess_dont_chain(void*)                __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
const void*          chess_dont_chain(const void*)          __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
volatile void*       chess_dont_chain(volatile void*)       __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
const volatile void* chess_dont_chain(const volatile void*) __attribute__((overloadable)) __attribute__((const)); //BUG does not preserve complete type
bool                 chess_keep_dead (bool)                 __attribute__((overloadable));
char                 chess_keep_dead (char)                 __attribute__((overloadable));
signed char          chess_keep_dead (signed char)          __attribute__((overloadable));
unsigned char        chess_keep_dead (unsigned char)        __attribute__((overloadable));
short                chess_keep_dead (short)                __attribute__((overloadable));
unsigned short       chess_keep_dead (unsigned short)       __attribute__((overloadable));
int                  chess_keep_dead (int)                  __attribute__((overloadable));
unsigned int         chess_keep_dead (unsigned int)         __attribute__((overloadable));
long                 chess_keep_dead (long)                 __attribute__((overloadable));
unsigned long        chess_keep_dead (unsigned long)        __attribute__((overloadable));
long long            chess_keep_dead (long long)            __attribute__((overloadable));
unsigned long long   chess_keep_dead (unsigned long long)   __attribute__((overloadable));
float                chess_keep_dead (float)                __attribute__((overloadable));
double               chess_keep_dead (double)               __attribute__((overloadable));
long double          chess_keep_dead (long double)          __attribute__((overloadable));
void*                chess_keep_dead (void*)                __attribute__((overloadable)); //BUG does not preserve complete type
const void*          chess_keep_dead (const void*)          __attribute__((overloadable)); //BUG does not preserve complete type
volatile void*       chess_keep_dead (volatile void*)       __attribute__((overloadable)); //BUG does not preserve complete type
const volatile void* chess_keep_dead (const volatile void*) __attribute__((overloadable)); //BUG does not preserve complete type
#endif

void chess_exit(int)                       __attribute__((overloadable));
void chess_stop(void)                      __attribute__((overloadable));
static void* volatile __attribute__((chess_alias_set(__chess_separator_universe))) __chess_separator_dummy;
static int   volatile __attribute__((chess_alias_set(__chess_separator_universe))) __chess_separator_idummy;
static inline __attribute__((always_inline,nodebug)) void chess_separator(void) __attribute__((overloadable)) { __chess_separator_dummy = (void*)0; }
static inline __attribute__((always_inline,nodebug)) void chess_separator_scheduler(void) __attribute__((overloadable)) { __chess_separator_dummy = (void*)1; }
static inline __attribute__((always_inline,nodebug)) void chess_separator_scheduler(int i) __attribute__((overloadable)) { __chess_separator_idummy = i; }
void chess_instruction_tracing_begin(void) __attribute__((overloadable));
void chess_instruction_tracing_end(void)   __attribute__((overloadable));
void chess_profile_begin(void)             __attribute__((overloadable));
void chess_profile_end(void)               __attribute__((overloadable));
void chess_hosted_io(void*)                __attribute__((overloadable));

#ifdef __cplusplus
#define chess_dont_care(T) chess_dont_care_<T>()
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wuninitialized"
template <typename T>
T chess_dont_care_() { T t; return t; }
#pragma clang diagnostic pop
#else
#define chess_dont_care(T) (T)0
#endif

#define __chess_pragma(x) _Pragma(#x)

#define chess_error(x) __builtin_chess_error(x)

// accept restrict also in C++/C89 mode
#define restrict __restrict

#define chess_message(x) /*native only*/

//  nil-defines for chess-specific keywords :

#define chess_alignof(x) (__alignof__(x))
#define chess_bitsof(x) (sizeof(x) * __CHAR_BIT__)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_closed_jump_table 
#else
# define chess_closed_jump_table _Pragma("message \"'chess_closed_jump_table' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
//-nap- chess_const_eval
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_direct 
#else
# define chess_direct _Pragma("message \"'chess_direct' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_dont_warn_dead(x) (x)
#define chess_dont_warn_range(x) (x)
#define chess_dont_warn_unroll
#ifdef __cplusplus
#define chess_elementsof(x) (chessLelementsof<typename chessllvm_remove_cv<typename chessllvm_remove_reference<typeof(x)>::type>::type>::value)
#endif
#define chess_flatten_loop  __chess_pragma(chessafterloop flatten_loop)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_frequent_else 
#else
# define chess_frequent_else _Pragma("message \"'chess_frequent_else' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_frequent_then 
#else
# define chess_frequent_then _Pragma("message \"'chess_frequent_then' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_guard 
#else
# define chess_guard _Pragma("message \"'chess_guard' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_guard_else 
#else
# define chess_guard_else _Pragma("message \"'chess_guard_else' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_inline_src_refs 
#else
# define chess_inline_src_refs _Pragma("message \"'chess_inline_src_refs' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_keep_if 
#else
# define chess_keep_if _Pragma("message \"'chess_keep_if' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_keep_sw_loop 
#else
# define chess_keep_sw_loop _Pragma("message \"'chess_keep_sw_loop' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_keep_sw_loop2 
#else
# define chess_keep_sw_loop2 _Pragma("message \"'chess_keep_sw_loop2' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_loop_count(x)   __chess_pragma(chessafterloop min_loop_count(x) max_loop_count(x))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_loop_count_storage(x) 
#else
# define chess_loop_count_storage(x) _Pragma("message \"'chess_loop_count_storage(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_loop_range(x,y) __chess_pragma(chessafterloop min_loop_count(x) max_loop_count(y))
#define chess_manifest(x) __builtin_chess_manifest(x)
#define chess_may_alias __attribute__((may_alias))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_no_hw_loop 
#else
# define chess_no_hw_loop _Pragma("message \"'chess_no_hw_loop' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_no_inline_src_refs 
#else
# define chess_no_inline_src_refs _Pragma("message \"'chess_no_inline_src_refs' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_no_jump_table 
#else
# define chess_no_jump_table _Pragma("message \"'chess_no_jump_table' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_open_jump_table 
#else
# define chess_open_jump_table _Pragma("message \"'chess_open_jump_table' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_output
#define chess_prepare_for_pipelining  __chess_pragma(chessafterloop prepare_for_pipelining)
#define chess_no_warn_pipelining
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_protect(x) (x)
#else
# define chess_protect(x) _Pragma("message \"'chess_protect(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")(x)
#endif
#define chess_protect_access __attribute__((chessLprotect_access))
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_protect_brk_cnt /*anachronistic*/
#else
# define chess_protect_brk_cnt _Pragma("message \"'chess_protect_brk_cnt' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")/*anachronistic*/
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_redirect 
#else
# define chess_redirect _Pragma("message \"'chess_redirect' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
//-nap- chess_relocator
//-nap- chess_rewrite
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_require_pipelining(x) 
#else
# define chess_require_pipelining(x) _Pragma("message \"'chess_require_pipelining(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_sequential 
#else
# define chess_sequential _Pragma("message \"'chess_sequential' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_single_instruction_repeat 
#else
# define chess_single_instruction_repeat _Pragma("message \"'chess_single_instruction_repeat' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_stack 
#else
# define chess_stack _Pragma("message \"'chess_stack' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#define chess_symbol(x) 0/*false*/
//-nap- chess_tcl_break(x) (?)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_unassign(x) (x)
#else
# define chess_unassign(x) _Pragma("message \"'chess_unassign(x)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")(x)
#endif
#define chess_unroll_loop(x) __chess_pragma(chessafterloop unroll_loop(x))
#define chess_unroll_loop_preamble __chess_pragma(chessafterloop unroll_loop_preamble)
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_used 
#else
# define chess_used _Pragma("message \"'chess_used' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_vector_guard 
#else
# define chess_vector_guard _Pragma("message \"'chess_vector_guard' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_vector_guard_else 
#else
# define chess_vector_guard_else _Pragma("message \"'chess_vector_guard_else' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_vector_sequential 
#else
# define chess_vector_sequential _Pragma("message \"'chess_vector_sequential' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif

// g++ and VC++ 8.0 or newer support variadic macro arguments
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_const(...) 0/*false*/
#else
# define chess_const(...) _Pragma("message \"'chess_const(...)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")0/*false*/
#endif
#ifdef LLVM_NO_WARN_IGNORED_CHESS
# define chess_string_segment(...) 
#else
# define chess_string_segment(...) _Pragma("message \"'chess_string_segment(...)' is ignored in the LLVM flow. (Use -DLLVM_NO_WARN_IGNORED_CHESS to disable this warning)\"")
#endif

// auxiliary macro to stringify macro arguments (after expansion)
#define chessLstr(...)              #__VA_ARGS__
// chess_storage annotations
#define chess_storage(...)          __attribute__((chessLstorage(__VA_ARGS__)))
// function pass-through attributes
#define clobbers(...)               __attribute__((chessFP(clobbers,chessLstr(__VA_ARGS__))))
#define clobbers_not(...)           __attribute__((chessFP(clobbers_not,chessLstr(__VA_ARGS__))))
#define property(...)               __attribute__((chessFP(property,chessLstr(__VA_ARGS__))))
#define value_across_call(...)      __attribute__((chessFP(value_across_call,chessLstr(__VA_ARGS__))))
#define value_across_call_not(...)  __attribute__((chessFP(value_across_call_not,chessLstr(__VA_ARGS__))))

unsigned long long chess_cycle_count(void) __attribute__((overloadable));



//  Application types (declaration)

#ifdef __cplusplus
template <typename T> struct chessLelementsof;
#endif


//  Application types (definition)

//  Application types (additional)

#ifndef do_not_generate_additional_appl_types /*trouble-shooting hook*/

typedef unsigned float32;

#endif /*do_not_generate_additional_appl_types*/


//  Reserved register variables

#ifndef do_not_generate_res_reg_vars /*trouble-shooting hook*/
#endif /*do_not_generate_res_reg_vars*/

//  Extern variables

#ifndef do_not_generate_ext_vars /*trouble-shooting hook*/
extern int float_detect_tininess;
extern int float_rounding_mode;
extern int float_exception_flags;
#endif /*do_not_generate_ext_vars*/

//  Operations

extern __C__ __regcall bool chessintr_bool_land_bool_bool(bool, bool) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool land(bool a0, bool a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_land_bool_bool(a0, a1);
}

extern __C__ __regcall bool chessintr_bool_lor_bool_bool(bool, bool) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool lor(bool a0, bool a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_lor_bool_bool(a0, a1);
}

extern __C__ __regcall bool chessintr_bool_lxor_bool_bool(bool, bool) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool lxor(bool a0, bool a1) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_lxor_bool_bool(a0, a1);
}

extern __C__ __regcall bool chessintr_bool_nez___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool nez(int a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_nez___sint(a0);
}

extern __C__ __regcall bool chessintr_bool_eqz___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool eqz(int a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_eqz___sint(a0);
}

extern __C__ __regcall bool chessintr_bool_nez___uint(unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool nez(unsigned a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_nez___uint(a0);
}

extern __C__ __regcall bool chessintr_bool_eqz___uint(unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool eqz(unsigned a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_eqz___uint(a0);
}

extern __C__ __regcall bool chessintr_bool_nez___Pvoid(void *) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool nez(void *a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_nez___Pvoid(a0);
}

extern __C__ __regcall bool chessintr_bool_eqz___Pvoid(void *) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool eqz(void *a0) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr_bool_eqz___Pvoid(a0);
}

#ifdef __cplusplus
struct chessout___sint_div_remainder___sint___sint___sint {
    int o0;
    int o1;
} __attribute__((packed));
extern __C__ __regcall struct chessout___sint_div_remainder___sint___sint___sint chessintr___sint_div_remainder___sint___sint___sint(int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int div_remainder(int a0, int a1, int &a2) __attribute__((overloadable))
{
    struct chessout___sint_div_remainder___sint___sint___sint out = chessintr___sint_div_remainder___sint___sint___sint(a0, a1);
    a2 = out.o1;
    return out.o0;
}
#endif

#ifdef __cplusplus
struct chessout___ulong_div_remainder___uint___uint___uint {
    unsigned long o0;
    unsigned o1;
} __attribute__((packed));
extern __C__ __regcall struct chessout___ulong_div_remainder___uint___uint___uint chessintr___ulong_div_remainder___uint___uint___uint(unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned long div_remainder(unsigned a0, unsigned a1, unsigned &a2) __attribute__((overloadable))
{
    struct chessout___ulong_div_remainder___uint___uint___uint out = chessintr___ulong_div_remainder___uint___uint___uint(a0, a1);
    a2 = out.o1;
    return out.o0;
}
#endif

#ifdef __cplusplus
struct chessout___slonglong_div_remainder___slonglong___slonglong___slonglong {
    long long o0;
    long long o1;
} __attribute__((packed));
extern __C__ __regcall struct chessout___slonglong_div_remainder___slonglong___slonglong___slonglong chessintr___slonglong_div_remainder___slonglong___slonglong___slonglong(long long, long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) long long div_remainder(long long a0, long long a1, long long &a2) __attribute__((overloadable))
{
    struct chessout___slonglong_div_remainder___slonglong___slonglong___slonglong out = chessintr___slonglong_div_remainder___slonglong___slonglong___slonglong(a0, a1);
    a2 = out.o1;
    return out.o0;
}
#endif

#ifdef __cplusplus
struct chessout___ulonglong_div_remainder___ulonglong___ulonglong___ulonglong {
    unsigned long long o0;
    unsigned long long o1;
} __attribute__((packed));
extern __C__ __regcall struct chessout___ulonglong_div_remainder___ulonglong___ulonglong___ulonglong chessintr___ulonglong_div_remainder___ulonglong___ulonglong___ulonglong(unsigned long long, unsigned long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned long long div_remainder(unsigned long long a0, unsigned long long a1, unsigned long long &a2) __attribute__((overloadable))
{
    struct chessout___ulonglong_div_remainder___ulonglong___ulonglong___ulonglong out = chessintr___ulonglong_div_remainder___ulonglong___ulonglong___ulonglong(a0, a1);
    a2 = out.o1;
    return out.o0;
}
#endif

extern __C__ __regcall int chessintr___sint_chess_bitfield_extract_signed___sint___sint___sint(int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int chess_bitfield_extract_signed(int a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___sint_chess_bitfield_extract_signed___sint___sint___sint(a0, a1, a2);
}

extern __C__ __regcall unsigned chessintr___uint_chess_bitfield_extract_unsigned___sint___sint___sint(int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned chess_bitfield_extract_unsigned(int a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___uint_chess_bitfield_extract_unsigned___sint___sint___sint(a0, a1, a2);
}

extern __C__ __regcall int chessintr___sint_chess_bitfield_update___sint___sint___sint___sint(int, int, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int chess_bitfield_update(int a0, int a1, int a2, int a3) __attribute__((overloadable))
{
    return chessintr___sint_chess_bitfield_update___sint___sint___sint___sint(a0, a1, a2, a3);
}

extern __C__ __regcall short chessintr___sshort_chess_bitfield_extract_signed___sshort___sint___sint(short, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) short chess_bitfield_extract_signed(short a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___sshort_chess_bitfield_extract_signed___sshort___sint___sint(a0, a1, a2);
}

extern __C__ __regcall unsigned short chessintr___ushort_chess_bitfield_extract_unsigned___sshort___sint___sint(short, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned short chess_bitfield_extract_unsigned(short a0, int a1, int a2) __attribute__((overloadable))
{
    return chessintr___ushort_chess_bitfield_extract_unsigned___sshort___sint___sint(a0, a1, a2);
}

extern __C__ __regcall short chessintr___sshort_chess_bitfield_update___sshort___sshort___sint___sint(short, short, int, int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) short chess_bitfield_update(short a0, short a1, int a2, int a3) __attribute__((overloadable))
{
    return chessintr___sshort_chess_bitfield_update___sshort___sshort___sint___sint(a0, a1, a2, a3);
}

extern __C__ __regcall int chessintr___sint_f32_to_i32___uint(float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int f32_to_i32(float32 a0) __attribute__((overloadable))
{
    return chessintr___sint_f32_to_i32___uint(a0);
}

extern __C__ __regcall float32 chessintr___uint_i32_to_f32___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32 i32_to_f32(int a0) __attribute__((overloadable))
{
    return chessintr___uint_i32_to_f32___sint(a0);
}

extern __C__ __regcall int chessintr___sint_as_int32___ffloat(float) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int as_int32(float a0) __attribute__((overloadable))
{
    return chessintr___sint_as_int32___ffloat(a0);
}

extern __C__ __regcall float chessintr___ffloat_as_float___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float as_float(int a0) __attribute__((overloadable))
{
    return chessintr___ffloat_as_float___sint(a0);
}

extern __C__ __regcall float32 chessintr___uint_f32_add___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32 f32_add(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr___uint_f32_add___uint___uint(a0, a1);
}

extern __C__ __regcall float32 chessintr___uint_f32_sub___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32 f32_sub(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr___uint_f32_sub___uint___uint(a0, a1);
}

extern __C__ __regcall float32 chessintr___uint_f32_mul___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32 f32_mul(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr___uint_f32_mul___uint___uint(a0, a1);
}

extern __C__ __regcall float32 chessintr___uint_f32_div___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32 f32_div(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr___uint_f32_div___uint___uint(a0, a1);
}

extern __C__ __regcall bool chessintr_bool_f32_le___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool f32_le(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr_bool_f32_le___uint___uint(a0, a1);
}

extern __C__ __regcall bool chessintr_bool_f32_lt___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool f32_lt(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr_bool_f32_lt___uint___uint(a0, a1);
}

extern __C__ __regcall bool chessintr_bool_f32_eq___uint___uint(float32, float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool f32_eq(float32 a0, float32 a1) __attribute__((overloadable))
{
    return chessintr_bool_f32_eq___uint___uint(a0, a1);
}

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall int chessintr___sint_f64_to_i32_dint(float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) int f64_to_i32(float64 a0) __attribute__((overloadable))
{
    return chessintr___sint_f64_to_i32_dint(a0);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float64 chessintr_dint_i32_to_f64___sint(int) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64 i32_to_f64(int a0) __attribute__((overloadable))
{
    return chessintr_dint_i32_to_f64___sint(a0);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float64 chessintr_dint_f32_to_f64___uint(float32) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64 f32_to_f64(float32 a0) __attribute__((overloadable))
{
    return chessintr_dint_f32_to_f64___uint(a0);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float32 chessintr___uint_f64_to_f32_dint(float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float32 f64_to_f32(float64 a0) __attribute__((overloadable))
{
    return chessintr___uint_f64_to_f32_dint(a0);
}
#endif
#endif

extern __C__ __regcall long long chessintr___slonglong_as_int64___fdouble(double) __attribute__((const));
inline __attribute__((always_inline,nodebug)) long long as_int64(double a0) __attribute__((overloadable))
{
    return chessintr___slonglong_as_int64___fdouble(a0);
}

extern __C__ __regcall double chessintr___fdouble_as_double___slonglong(long long) __attribute__((const));
inline __attribute__((always_inline,nodebug)) double as_double(long long a0) __attribute__((overloadable))
{
    return chessintr___fdouble_as_double___slonglong(a0);
}

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float64 chessintr_dint_f64_add_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64 f64_add(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_dint_f64_add_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float64 chessintr_dint_f64_sub_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64 f64_sub(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_dint_f64_sub_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float64 chessintr_dint_f64_mul_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64 f64_mul(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_dint_f64_mul_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall float64 chessintr_dint_f64_div_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) float64 f64_div(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_dint_f64_div_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall bool chessintr_bool_f64_le_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool f64_le(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_bool_f64_le_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall bool chessintr_bool_f64_lt_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool f64_lt(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_bool_f64_lt_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern __C__ __regcall bool chessintr_bool_f64_eq_dint_dint(float64, float64) __attribute__((const));
inline __attribute__((always_inline,nodebug)) bool f64_eq(float64 a0, float64 a1) __attribute__((overloadable))
{
    return chessintr_bool_f64_eq_dint_dint(a0, a1);
}
#endif
#endif

#ifdef __cplusplus
struct chessout_void_sha256_ci___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint {
    unsigned o1;
    unsigned o2;
    unsigned o3;
    unsigned o4;
    unsigned o5;
    unsigned o6;
    unsigned o7;
    unsigned o8;
} __attribute__((packed));
extern __C__ __regcall struct chessout_void_sha256_ci___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint chessintr_void_sha256_ci___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint(unsigned, unsigned, unsigned, unsigned, unsigned, unsigned, unsigned, unsigned, unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) void sha256_ci(unsigned a0, unsigned a1, unsigned a2, unsigned a3, unsigned a4, unsigned a5, unsigned a6, unsigned a7, unsigned a8, unsigned a9, unsigned &a10, unsigned &a11, unsigned &a12, unsigned &a13, unsigned &a14, unsigned &a15, unsigned &a16, unsigned &a17) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    struct chessout_void_sha256_ci___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint out = chessintr_void_sha256_ci___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint___uint(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    a17 = out.o8;
    a16 = out.o7;
    a15 = out.o6;
    a14 = out.o5;
    a13 = out.o4;
    a12 = out.o3;
    a11 = out.o2;
    a10 = out.o1;
    return ;
}
#endif

extern __C__ __regcall unsigned chessintr___uint_sha256_in1___uint___uint___uint___uint(unsigned, unsigned, unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned sha256_in1(unsigned a0, unsigned a1, unsigned a2, unsigned a3) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_sha256_in1___uint___uint___uint___uint(a0, a1, a2, a3);
}

extern __C__ __regcall unsigned chessintr___uint_sha256_in2___uint___uint___uint___uint(unsigned, unsigned, unsigned, unsigned) __attribute__((const));
inline __attribute__((always_inline,nodebug)) unsigned sha256_in2(unsigned a0, unsigned a1, unsigned a2, unsigned a3) __attribute__((overloadable)) __attribute__((chessFP(llvm_local_block_replace_operand_with_variable)))
{
    return chessintr___uint_sha256_in2___uint___uint___uint___uint(a0, a1, a2, a3);
}

extern __C__ __regcall void chess_storage(PM) * chessintr___PPMvoid_chess_return_address(void) __attribute__((const));
inline __attribute__((always_inline,nodebug)) void chess_storage(PM) *chess_return_address(void) __attribute__((overloadable))
{
    return chessintr___PPMvoid_chess_return_address();
}



// do_generate[_llvm] inline functions

#ifdef __cplusplus
extern int div_called(int, int, chess_output int &);
#endif

#ifdef __cplusplus
extern unsigned div_called(unsigned, unsigned, chess_output unsigned &);
#endif

#ifdef __cplusplus
extern long long div_called(long long, long long, chess_output long long &);
#endif

#ifdef __cplusplus
extern unsigned long long div_called(unsigned long long, unsigned long long, chess_output unsigned long long &);
#endif

    inline __attribute__((always_inline)) void char_memory_copy(volatile char *l, const volatile char *r, const int sz) __attribute__((overloadable))
    {
     char *ll = (char *)l;
     char *rr = (char *)r;
     if (sz < 5)
      {
       if (sz >= 1)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 2)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 3)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 4)
        *ll = *rr;
       else
        ;
      }
     else
      for (int ii = 0;
           ii < sz; ii++)
       ll[ii] = rr[ii];
    }

    inline __attribute__((always_inline)) void short_memory_copy(volatile short *l, const volatile short *r, const int sz) __attribute__((overloadable))
    {
     short *ll = (short *)l;
     short *rr = (short *)r;
     if (sz < 5)
      {
       if (sz >= 1)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 2)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 3)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 4)
        *ll = *rr;
       else
        ;
      }
     else
      for (int ii = 0;
           ii < sz; ii++)
       ll[ii] = rr[ii];
    }

    inline __attribute__((always_inline)) void int_memory_copy(volatile int *l, const volatile int *r, const int sz) __attribute__((overloadable))
    {
     int *ll = (int *)l;
     int *rr = (int *)r;
     if (sz < 5)
      {
       if (sz >= 1)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 2)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 3)
        * ll++ = * rr++;
       else
        ;
       if (sz >= 4)
        *ll = *rr;
       else
        ;
      }
     else
      for (int ii = 0;
           ii < sz; ii++)
       ll[ii] = rr[ii];
    }

    inline __attribute__((always_inline)) void chess_memory_copy(volatile void *l, const volatile void *r, const int sz, const int algn) __attribute__((overloadable))
    {
     if (algn == sizeof(char))
      char_memory_copy((char *)l,(char *)r,sz / sizeof(char));
     else
      if (algn == sizeof(short))
       short_memory_copy((short *)l,(short *)r,sz / sizeof(short));
      else
       if (algn == sizeof(int))
        int_memory_copy((int *)l,(int *)r,sz / sizeof(int));
       else
        ;
    }

    inline __attribute__((always_inline)) void float_raise(int flags) __attribute__((overloadable))
    {
    }

extern float32 int32_to_float32(int);

#ifdef __cplusplus
#if 0//not yet
extern float64 int32_to_float64(int);
#endif
#endif

extern int float32_to_int32(float32);

extern int float32_to_int32_round_to_zero(float32);

#ifdef __cplusplus
#if 0//not yet
extern float64 float32_to_float64(float32);
#endif
#endif

extern float32 float32_round_to_int(float32);

extern float32 float32_add(float32, float32);

extern float32 float32_sub(float32, float32);

extern float32 float32_mul(float32, float32);

extern float32 float32_div(float32, float32);

extern float32 float32_rem(float32, float32);

extern float32 float32_sqrt(float32);

extern int float32_eq(float32, float32);

extern int float32_le(float32, float32);

extern int float32_lt(float32, float32);

extern int float32_eq_signaling(float32, float32);

extern int float32_le_quiet(float32, float32);

extern int float32_lt_quiet(float32, float32);

    inline __attribute__((always_inline)) int float32_is_signaling_nan(float32 a) __attribute__((overloadable))
    {
     return (a >> 22 & 511) == 510 && a & 4194303;
    }

#ifdef __cplusplus
#if 0//not yet
extern int float64_to_int32(float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_to_int32_round_to_zero(float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float32 float64_to_float32(float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_round_to_int(float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_add(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_sub(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_mul(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_div(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_rem(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern float64 float64_sqrt(float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_eq(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_le(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_lt(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_eq_signaling(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_le_quiet(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
extern int float64_lt_quiet(float64, float64);
#endif
#endif

#ifdef __cplusplus
#if 0//not yet
    inline __attribute__((always_inline)) int float64_is_signaling_nan(float64 a) __attribute__((overloadable))
    {
     return (a.high >> 19 & 4095) == 4094 && (a.low || a.high & 524287);
    }
#endif
#endif

#ifdef __cplusplus
    inline __attribute__((always_inline)) void sha256_ci(unsigned &a, unsigned &b, unsigned &c, unsigned &d, unsigned &e, unsigned &f, unsigned &g, unsigned &h, unsigned ki, unsigned mi) __attribute__((overloadable))
    {
     sha256_ci(a,b,c,d,e,f,g,h,ki,mi,a,b,c,d,e,f,g,h);
    }
#endif


#undef __C__
#ifdef __cplusplus
#undef __STUB_DEFAULT__
#else
#undef bool
#endif

#pragma clang diagnostic pop

#endif /*_tlx_chess_llvm_h*/
