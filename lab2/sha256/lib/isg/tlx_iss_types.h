
// File generated by noodle version N-2018.03#7d02e3ca79#180723, Thu Feb 28 14:33:25 2019
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -ps -B -Iisg +wisg -I../../io_modules -I/CMC/tools/synopsys/asip_designer_vN-2018.03-SP3/linux64/chessdir/../examples/io_modules -D__tct_patch__=300 -D__checkers__ tlx

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Primitive types and functions
// used in Checkers ISS and PDG (and possibly native)

#ifndef _tlx_iss_types_h
#define _tlx_iss_types_h

#include "chess.h"
#include "vbit.h"

namespace tlx_primitive {

//  Primitive types (declarations)

class w08;              // property(  8 bit   signed );
class w16;              // property( 16 bit   signed );
class w32;              // property( 32 bit   signed );
class addr;             // property( 32 bit unsigned );
class iword;            // property( 32 bit unsigned );
class uint1;            // property(  1 bit unsigned );
class uint4;            // property(  4 bit unsigned );
class uint5;            // property(  5 bit unsigned );
class uint16;           // property( 16 bit unsigned );
class int5;             // property(  5 bit   signed );
class int16;            // property( 16 bit   signed );
class int16p;           // property( 16 bit   signed );
class int26;            // property( 26 bit   signed );


//  Primitive types (definitions)

class w08
{
public:
    typedef VBit<8, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w08() {}
    template <int B, bool S> w08(const VBit<B, S>& a) : val(a) {}
    w08(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w08(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w08(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w08& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w08& x) { is >> x.val; return is; }
public:
};
inline const w08::BitType& toBitType(const w08& v) { return v.val; }

class w16
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w16() {}
    template <int B, bool S> w16(const VBit<B, S>& a) : val(a) {}
    w16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w16& x) { is >> x.val; return is; }
public:
};
inline const w16::BitType& toBitType(const w16& v) { return v.val; }

class w32
{
public:
    typedef VBit<32, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w32() {}
    template <int B, bool S> w32(const VBit<B, S>& a) : val(a) {}
    w32(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w32(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w32(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w32& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w32& x) { is >> x.val; return is; }
public:
    w32(int16);
    w32(uint16);
    w32(int5);
};
inline const w32::BitType& toBitType(const w32& v) { return v.val; }

class addr
{
public:
    typedef VBit<32, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    addr() {}
    template <int B, bool S> addr(const VBit<B, S>& a) : val(a) {}
    addr(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> addr(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    addr(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const addr& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, addr& x) { is >> x.val; return is; }
public:
    addr(w32);
};
inline const addr::BitType& toBitType(const addr& v) { return v.val; }

class iword
{
public:
    typedef VBit<32, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    iword() {}
    template <int B, bool S> iword(const VBit<B, S>& a) : val(a) {}
    iword(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> iword(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    iword(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const iword& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, iword& x) { is >> x.val; return is; }
public:
};
inline const iword::BitType& toBitType(const iword& v) { return v.val; }

class uint1
{
public:
    typedef VBit<1, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint1() {}
    template <int B, bool S> uint1(const VBit<B, S>& a) : val(a) {}
    uint1(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint1(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint1(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint1& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint1& x) { is >> x.val; return is; }
public:
};
inline const uint1::BitType& toBitType(const uint1& v) { return v.val; }

class uint4
{
public:
    typedef VBit<4, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint4() {}
    template <int B, bool S> uint4(const VBit<B, S>& a) : val(a) {}
    uint4(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint4(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint4(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint4& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint4& x) { is >> x.val; return is; }
public:
};
inline const uint4::BitType& toBitType(const uint4& v) { return v.val; }

class uint5
{
public:
    typedef VBit<5, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint5() {}
    template <int B, bool S> uint5(const VBit<B, S>& a) : val(a) {}
    uint5(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint5(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint5(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint5& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint5& x) { is >> x.val; return is; }
public:
};
inline const uint5::BitType& toBitType(const uint5& v) { return v.val; }

class uint16
{
public:
    typedef VBit<16, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint16() {}
    template <int B, bool S> uint16(const VBit<B, S>& a) : val(a) {}
    uint16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint16& x) { is >> x.val; return is; }
public:
};
inline const uint16::BitType& toBitType(const uint16& v) { return v.val; }

class int5
{
public:
    typedef VBit<5, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int5() {}
    template <int B, bool S> int5(const VBit<B, S>& a) : val(a) {}
    int5(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int5(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int5(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int5& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int5& x) { is >> x.val; return is; }
public:
};
inline const int5::BitType& toBitType(const int5& v) { return v.val; }

class int16
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int16() {}
    template <int B, bool S> int16(const VBit<B, S>& a) : val(a) {}
    int16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int16& x) { is >> x.val; return is; }
public:
};
inline const int16::BitType& toBitType(const int16& v) { return v.val; }

class int16p
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int16p() {}
    template <int B, bool S> int16p(const VBit<B, S>& a) : val(a) {}
    int16p(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int16p(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int16p(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int16p& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int16p& x) { is >> x.val; return is; }
public:
};
inline const int16p::BitType& toBitType(const int16p& v) { return v.val; }

class int26
{
public:
    typedef VBit<26, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int26() {}
    template <int B, bool S> int26(const VBit<B, S>& a) : val(a) {}
    int26(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int26(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int26(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int26& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int26& x) { is >> x.val; return is; }
public:
};
inline const int26::BitType& toBitType(const int26& v) { return v.val; }


//  Conversions

inline w32::w32(int16 a)                 { val = toVBit(a); }
inline w32::w32(uint16 a)                { val = toVBit(a); }
inline w32::w32(int5 a)                  { val = toVBit(a); }

inline addr::addr(w32 a)                 { val = toVBit(a); }

inline w32 lhi(int16p a)                { return w32::BitType((w32::BitType(toVBit(a)) << 16)); }

//  Operations

checkers_import_export /*primitive*/ w32 add(w32, w32, uint1 &);
checkers_import_export /*primitive*/ w32 add(w32, w32);
checkers_import_export /*primitive*/ w32 sub(w32, w32, uint1 &);

checkers_import_export /*primitive*/ w32 addx(w32, w32, uint1, uint1 &);
checkers_import_export /*primitive*/ w32 subx(w32, w32, uint1, uint1 &);

checkers_import_export /*primitive*/ w32 band(w32, w32);
checkers_import_export /*primitive*/ w32 bor(w32, w32);
checkers_import_export /*primitive*/ w32 bxor(w32, w32);
checkers_import_export /*primitive*/ w32 xtd(w32, w32);

checkers_import_export /*primitive*/ w32 mul(w32, w32);

checkers_import_export /*primitive*/ void lmulss(w32, w32, w32 &, w32 &);
checkers_import_export /*primitive*/ void lmulsu(w32, w32, w32 &, w32 &);
checkers_import_export /*primitive*/ void lmuluu(w32, w32, w32 &, w32 &);
checkers_import_export /*primitive*/ w32 clb(w32);

checkers_import_export /*primitive*/ w32 sll(w32, w32);
checkers_import_export /*primitive*/ w32 srl(w32, w32);
checkers_import_export /*primitive*/ w32 sra(w32, w32);

checkers_import_export /*primitive*/ w32 sge(w32, w32);
checkers_import_export /*primitive*/ w32 sgt(w32, w32);
checkers_import_export /*primitive*/ w32 sle(w32, w32);
checkers_import_export /*primitive*/ w32 slt(w32, w32);
checkers_import_export /*primitive*/ w32 sgeu(w32, w32);
checkers_import_export /*primitive*/ w32 sgtu(w32, w32);
checkers_import_export /*primitive*/ w32 sleu(w32, w32);
checkers_import_export /*primitive*/ w32 sltu(w32, w32);
checkers_import_export /*primitive*/ w32 seq(w32, w32);
checkers_import_export /*primitive*/ w32 sne(w32, w32);

checkers_import_export /*primitive*/ w32 extend_sign(w08);
checkers_import_export /*primitive*/ w32 extend_zero(w08);
checkers_import_export /*primitive*/ w32 extend_sign(w16);
checkers_import_export /*primitive*/ w32 extend_zero(w16);
checkers_import_export /*primitive*/ w08 extract_w08(w32);
checkers_import_export /*primitive*/ w16 extract_w16(w32);

checkers_import_export /*primitive*/ void sha256_ci(w32, w32, w32, w32, w32, w32, w32, w32, w32, w32, w32 &, w32 &, w32 &, w32 &, w32 &, w32 &, w32 &, w32 &);

checkers_import_export /*primitive*/ w32 sha256_in1(w32, w32, w32, w32);
checkers_import_export /*primitive*/ w32 sha256_in2(w32, w32, w32, w32);

checkers_import_export /*primitive*/ bool eqz(w32);
checkers_import_export /*primitive*/ bool nez(w32);
checkers_import_export /*primitive*/ w32 seq0(w32);
checkers_import_export /*primitive*/ w32 sne0(w32);

//cntrl:  checkers_import_export /*primitive*/ void br(bool, int16);
//cntrl:  checkers_import_export /*primitive*/ void j(int26);
//cntrl:  checkers_import_export /*primitive*/ void jr(w32);
checkers_import_export /*primitive*/ void nop();

//cntrl:  checkers_import_export /*primitive*/ void jal(int26);
//cntrl:  checkers_import_export /*primitive*/ void jalr(w32);
checkers_import_export /*primitive*/ w32 pcadd(w32, w32);

checkers_import_export /*primitive*/ w32 sign_extend_08(w32);
checkers_import_export /*primitive*/ w32 zero_extend_08(w32);
checkers_import_export /*primitive*/ w32 sign_extend_16(w32);
checkers_import_export /*primitive*/ w32 zero_extend_16(w32);


} //namespace tlx_primitive

#endif /*_tlx_iss_types_h*/
